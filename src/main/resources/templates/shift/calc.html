<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout}">
<head>
  <title>日次シフト表示</title>
</head>
<body>
<div layout:fragment="content">
  <div class="content-header">
    <h1><i class="bi bi-calendar-day"></i> 日次シフト表示</h1>
    <p class="mb-0">日別のシフト割り当て結果を確認できます</p>
  </div>

<div class="row g-4">
  <!-- Control Panel -->
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="bi bi-sliders"></i> 表示設定</h5>
      </div>
      <div class="card-body">
        <div class="row g-3 align-items-end">
          <div class="col-md-3">
            <label class="form-label fw-semibold">
              <i class="bi bi-calendar-day me-1"></i>表示日
            </label>
            <input type="date" id="date" class="form-control form-control-lg">
          </div>
          <div class="col-md-3">
            <label class="form-label fw-semibold">
              <i class="bi bi-shop me-1"></i>店舗
            </label>
            <select id="storeCode" class="form-select form-select-lg">
              <option value="569">569 - テスト店舗</option>
            </select>
          </div>
          <div class="col-md-3">
            <div class="btn-group w-100" role="group">
              <button id="btnPrevDay" class="btn btn-outline-secondary">
                <i class="bi bi-chevron-left"></i> 前日
              </button>
              <button id="btnSearch" class="btn btn-primary">
                <i class="bi bi-search"></i> 検索
              </button>
              <button id="btnNextDay" class="btn btn-outline-secondary">
                翌日 <i class="bi bi-chevron-right"></i>
              </button>
            </div>
          </div>
          <div class="col-md-3">
            <button id="btnToday" class="btn btn-success w-100">
              <i class="bi bi-calendar-today"></i> 今日
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Hard Constraint Violation Alert -->
<div class="row g-4" id="constraintAlertContainer" style="display: none;">
  <div class="col-12">
    <div class="alert alert-danger" role="alert">
      <div class="d-flex align-items-start">
        <i class="bi bi-exclamation-triangle-fill me-3" style="font-size: 1.5rem; margin-top: 0.125rem;"></i>
        <div class="flex-grow-1">
          <h5 class="alert-heading mb-2">⚠️ ハード制約違反が検出されました</h5>
          <div id="constraintViolationMessages"></div>
          <hr class="my-3">
          <p class="mb-0">
            <strong>対処方法:</strong> 上記の制約違反を解決してから再度最適化を実行してください。
            制約違反がある状態では結果を保存できません。
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Staffing Balance Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="staffingBalanceCard" style="display: none;">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-graph-up-arrow me-2"></i>時間帯別人時過不足
        </h5>
      </div>
      <div class="card-body p-0">
        <div class="table-responsive" id="staffingBalanceContainer" style="max-height: 250px; overflow-x: auto; overflow-y: auto;">
          <div id="staffingBalanceGrid" class="shift-grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Work Model Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="workModelCard" style="display: none;">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-bar-chart me-2"></i>作業モデル（必要レジ台数）
        </h5>
      </div>
      <div class="card-body p-0">
        <div class="table-responsive" id="workModelContainer" style="max-height: 400px; overflow-x: auto; overflow-y: auto;">
          <div id="workModelGrid" class="shift-grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Results Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="resultsCard">
      <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">
          <i class="bi bi-table me-2"></i>シフト割り当て結果
        </h5>
        <div class="d-flex align-items-center gap-3">
          <div class="text-muted small" id="displayDate">
            表示日を選択してください
          </div>
          <button id="saveChangesBtn" class="btn btn-success btn-sm" style="display: none;">
            <i class="bi bi-floppy"></i> 変更を保存
          </button>
          <button id="cancelChangesBtn" class="btn btn-secondary btn-sm" style="display: none;">
            <i class="bi bi-x-circle"></i> キャンセル
          </button>
        </div>
      </div>
      <div class="card-body p-0">
        <div class="alert alert-info m-3" id="dragDropHelp">
          <div class="d-flex align-items-center">
            <i class="bi bi-info-circle me-2"></i>
            <div>
              <strong>使い方:</strong> 
              <strong>ドラッグ:</strong> 割り当て済みセルを他の従業員の同じ時間にドラッグして移動 |
              <strong>右クリック:</strong> セルを右クリックで割り当て・変更・解除メニュー
            </div>
          </div>
        </div>
        <div id="noDataMessage" class="text-center py-5 text-muted">
          <i class="bi bi-calendar-x display-4 d-block mb-3"></i>
          <h6>シフトデータがありません</h6>
          <p class="mb-0">日付を選択して検索ボタンを押してください</p>
        </div>
        <div class="table-responsive" style="max-height: 600px; overflow-x: auto; overflow-y: auto; display: none;" id="tableContainer">
          <div id="shiftGrid" class="shift-grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .shift-grid-container {
    display: grid;
    grid-template-columns: 120px repeat(96, 50px);
    gap: 1px;
    border: 1px solid #dee2e6;
    min-width: 4920px; /* 120px + (96 * 50px) + gaps */
    width: max-content;
  }
  
  .grid-header, .grid-cell {
    padding: 8px 4px;
    text-align: center;
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    white-space: nowrap;
    font-size: 0.75rem;
  }
  
  .grid-header.time-slot {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 1;
  }
  
  .grid-row-header {
    font-weight: 700;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    position: sticky;
    left: 0;
    z-index: 1;
  }
  
  .grid-cell.assigned {
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
  }
  
  .grid-cell.assigned.color-0 { background: linear-gradient(135deg, #28a745, #20c997); }
  .grid-cell.assigned.color-1 { background: linear-gradient(135deg, #007bff, #6610f2); }
  .grid-cell.assigned.color-2 { background: linear-gradient(135deg, #ffc107, #fd7e14); }
  .grid-cell.assigned.color-3 { background: linear-gradient(135deg, #dc3545, #e83e8c); }
  .grid-cell.assigned.color-4 { background: linear-gradient(135deg, #6c757d, #495057); }
  
  /* 勤務時間（レジ未割当も含む）の背景色 */
  .work-hours-cell.working {
    background: #fff3cd;   /* light amber */
    color: #856404;
    border: 1px solid #ffeaa7;
  }
  
  .employee-shift-cell {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    font-size: 0.7rem;
    font-weight: 600;
  }
  
  .grid-cell.assigned[draggable="true"] {
    cursor: grab;
    position: relative;
  }
  
  .grid-cell.assigned[draggable="true"]:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transform: translateY(-1px);
  }
  
  .grid-cell.assigned.dragging {
    opacity: 0.5;
    cursor: grabbing;
    transform: rotate(3deg) scale(0.95);
    z-index: 1000;
  }
  
  .grid-cell.assigned[draggable="true"]:hover::after {
    content: "\\f47a"; /* Bootstrap grip icon */
    font-family: "Bootstrap Icons";
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.7);
  }
  
  .drop-zone {
    transition: all 0.2s ease;
  }
  
  .drop-zone.drag-over {
    background: linear-gradient(135deg, #e8f5e8, #c8e6c9) !important;
    border: 2px dashed #4caf50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
  }
  
  .drop-zone.modified {
    border: 2px solid #28a745;
    box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
  }
  
  .register-selector {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #007bff;
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 1000;
    display: none;
  }
  
  .register-selector.show {
    display: block;
  }
  
  .context-menu {
    position: absolute;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1500;
    min-width: 150px;
    padding: 4px 0;
    display: none;
  }
  
  .context-menu.show {
    display: block;
  }
  
  .context-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    font-size: 0.875rem;
    color: #495057;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .context-menu-item:hover {
    background: #f8f9fa;
    color: #0d6efd;
  }
  
  .context-menu-item.danger {
    color: #dc3545;
  }
  
  .context-menu-item.danger:hover {
    background: #f8f9fa;
    color: #dc3545;
  }
  
  .context-menu-divider {
    height: 1px;
    background: #dee2e6;
    margin: 4px 0;
  }
  
  .employee-name {
    font-size: 0.8rem;
    font-weight: 600;
    color: white;
    line-height: 1.2;
  }
  
  .employee-code {
    font-size: 0.7rem;
    color: rgba(255,255,255,0.8);
    margin-top: 2px;
  }
  
  .work-model-cell {
    position: relative;
    padding: 2px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: 600;
    border: 1px solid #dee2e6;
  }
  
  .work-model-cell.register-needed {
    background: linear-gradient(135deg, #28a745, #20c997);
    border: 1px solid #1e7e34;
  }
  
  .work-model-cell.register-needed.has-employee {
    background: linear-gradient(135deg, #007bff, #0056b3);
    border: 1px solid #0056b3;
    color: white;
    font-weight: 600;
    font-size: 0.65rem;
    display: flex;
    align-items: center;
    justify-content: center;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  
  .work-model-cell-empty {
    background: transparent;
    border: none;
    height: 35px;
  }
  
  
  .staffing-balance-cell {
    position: relative;
    padding: 4px;
    height: 35px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    font-weight: 600;
    border: 1px solid #dee2e6;
    background: #f8f9fa;
  }
  
  .staffing-balance-cell.shortage {
    background: linear-gradient(135deg, #dc3545, #c82333);
    color: white;
    border: 1px solid #c82333;
  }
  
  .staffing-balance-cell.excess {
    background: linear-gradient(135deg, #ffc107, #e0a800);
    color: #212529;
    border: 1px solid #e0a800;
  }
  
  .staffing-balance-cell.balanced {
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    border: 1px solid #20c997;
  }
  
  .balance-value {
    font-size: 0.6rem;
    font-weight: 700;
  }
  
  .balance-detail {
    font-size: 0.5rem;
    opacity: 0.8;
  }
  
  .work-hours-cell {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    color: #6c757d;
    font-size: 0.65rem;
    font-weight: 600;
    text-align: center;
    padding: 2px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .break-assigned {
    background: linear-gradient(135deg, #17a2b8, #138496);
    color: white;
    border: 1px solid #138496;
  }
  
  .break-assigned::before {
    content: "休";
    font-size: 0.7rem;
    font-weight: 700;
  }
</style>

<script>
const $=id=>document.getElementById(id);

// 編集状態管理
let isEditing = false;
let hasChanges = false;
let changes = new Map(); // key: employeeCode_time, value: {original, current}

// Function to generate a consistent color based on employee name
function getEmployeeColorClass(employeeName) {
  let hash = 0;
  for (let i = 0; i < employeeName.length; i++) {
    hash = employeeName.charCodeAt(i) + ((hash << 5) - hash);
  }
  return `color-${Math.abs(hash) % 5}`; // Use 5 distinct colors
}

// ドラッグアンドドロップと右クリックメニュー処理
let draggedAssignment = null;
let registerSelector = null;
let contextMenu = null;

// 割り当てセルのドラッグ処理
function handleAssignmentDragStart(event) {
  const cell = event.target;
  draggedAssignment = {
    sourceCell: cell,
    employeeCode: cell.dataset.employee,
    employeeName: cell.dataset.employeeName,
    time: cell.dataset.time,
    registerNo: cell.dataset.currentRegister,
    assignedEmployeeName: cell.dataset.assignedEmployeeName
  };
  
  cell.classList.add('dragging');
  event.dataTransfer.effectAllowed = 'move';
  event.dataTransfer.setData('text/plain', '');
}

function handleAssignmentDragEnd(event) {
  event.target.classList.remove('dragging');
  draggedAssignment = null;
  
  // 全てのdrag-overクラスを削除
  document.querySelectorAll('.drag-over').forEach(cell => {
    cell.classList.remove('drag-over');
  });
  
  hideContextMenu();
}

function handleDragOver(event) {
  if (!draggedAssignment) return;
  
  event.preventDefault();
  event.dataTransfer.dropEffect = 'move';
  
  const cell = event.currentTarget;
  const targetEmployee = cell.dataset.employee;
  const sourceEmployee = draggedAssignment.employeeCode;
  
  // 異なる従業員のセルのみドロップ可能
  if (targetEmployee !== sourceEmployee) {
    cell.classList.add('drag-over');
  }
}

function handleDragLeave(event) {
  const cell = event.currentTarget;
  cell.classList.remove('drag-over');
}

function handleDrop(event) {
  event.preventDefault();
  
  if (!draggedAssignment) return;
  
  const cell = event.currentTarget;
  cell.classList.remove('drag-over');
  
  const targetEmployee = cell.dataset.employee;
  const sourceEmployee = draggedAssignment.employeeCode;
  const targetTime = draggedAssignment.time;
  
  // 異なる従業員への移動のみ許可
  if (targetEmployee !== sourceEmployee) {
    moveAssignmentToEmployee(draggedAssignment, targetEmployee, targetTime);
  }
}

function showRegisterSelectorForCell(cell) {
  hideRegisterSelector();
  
  const currentRegister = cell.dataset.currentRegister || '';
  
  // レジスターセレクターを作成
  registerSelector = document.createElement('div');
  registerSelector.className = 'register-selector show';
  registerSelector.innerHTML = `
    <div class="mb-2"><strong>レジを選択:</strong></div>
    <div class="btn-group-vertical" role="group">
      <button type="button" class="btn btn-outline-secondary btn-sm" data-register="">未割当</button>
      <button type="button" class="btn btn-outline-info btn-sm" data-register="break">休憩</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="1">レジ1</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="2">レジ2</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="3">レジ3</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="4">レジ4</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="5">レジ5</button>
    </div>
  `;
  
  // 現在のレジが選択されている場合はハイライト
  const currentButton = registerSelector.querySelector(`[data-register="${currentRegister}"]`);
  if (currentButton) {
    currentButton.classList.remove('btn-outline-primary', 'btn-outline-secondary');
    currentButton.classList.add('btn-primary');
  }
  
  // イベントリスナーを追加
  registerSelector.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const registerValue = e.target.dataset.register;
      assignRegisterToCell(cell, registerValue);
      hideRegisterSelector();
    });
  });
  
  // セルに配置
  cell.style.position = 'relative';
  cell.appendChild(registerSelector);
  
  // 外側クリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', closeRegisterSelectorOnOutsideClick);
  }, 10);
}

function hideRegisterSelector() {
  if (registerSelector) {
    registerSelector.remove();
    registerSelector = null;
    document.removeEventListener('click', closeRegisterSelectorOnOutsideClick);
  }
}

function closeRegisterSelectorOnOutsideClick(event) {
  if (registerSelector && !registerSelector.contains(event.target)) {
    hideRegisterSelector();
  }
}

function assignRegisterToCell(cell, newValue, assignedEmployeeName = null) {
  const employeeCode = cell.dataset.employee;
  const time = cell.dataset.time;
  const originalValue = cell.dataset.originalRegister || '';
  const key = `${employeeCode}_${time}`;
  
  if (newValue !== originalValue) {
    // 変更があった場合
    changes.set(key, {
      employeeCode,
      time,
      original: originalValue,
      current: newValue
    });
    
    cell.dataset.currentRegister = newValue;
    cell.classList.add('modified');
    
    if (newValue) {
      cell.classList.add('assigned');
      const employeeNameForColor = assignedEmployeeName || cell.dataset.employeeName;
      
      if (newValue === 'break') {
        // 休憩の場合
        cell.classList.add('break-assigned');
        cell.textContent = '';
      } else {
        // レジ割り当ての場合
        const colorClass = getEmployeeColorClass(employeeNameForColor);
        cell.classList.add(colorClass);
        cell.textContent = `R${newValue}`;
        // 勤務時間外であっても、このスロットを勤務時間として取り込む
        try {
          addWorkingSlot(cell.dataset.employee, cell.dataset.time);
        } catch(e) { console.warn('addWorkingSlot failed', e); }
      }
      
      cell.dataset.assignedEmployeeName = employeeNameForColor;
      
      // ドラッグ可能にする（重複イベント防止）
      cell.draggable = true;
      cell.removeEventListener('dragstart', handleAssignmentDragStart);
      cell.removeEventListener('dragend', handleAssignmentDragEnd);
      cell.addEventListener('dragstart', handleAssignmentDragStart);
      cell.addEventListener('dragend', handleAssignmentDragEnd);
    } else {
      cell.classList.remove('assigned', 'break-assigned');
      cell.textContent = '';
      cell.classList.remove('color-0', 'color-1', 'color-2', 'color-3', 'color-4');
      cell.draggable = false;
      cell.removeEventListener('dragstart', handleAssignmentDragStart);
      cell.removeEventListener('dragend', handleAssignmentDragEnd);
    }
    
    hasChanges = true;
    showSaveButtons();
    
    // 作業モデル、人時過不足、勤務時間を更新
    updateWorkModel();
    updateStaffingBalance();
    updateWorkHours();
  } else {
    // 変更なし
    changes.delete(key);
    cell.classList.remove('modified');
    
    if (changes.size === 0) {
      hasChanges = false;
      hideSaveButtons();
    }
  }
}

// 指定の従業員・時刻(HH:mm)の15分スロットを勤務時間として取り込む
function addWorkingSlot(employeeCode, timeHHmm) {
  const dateStr = document.getElementById('date').value; // YYYY-MM-DD
  if (!dateStr) return;

  // work-hours セルに薄色背景を付与
  const workCell = document.querySelector(`.work-hours-cell[data-employee="${employeeCode}"][data-time="${timeHHmm}"]`);
  if (workCell) workCell.classList.add('working');

  // _workShiftsOfDay を15分スロットで拡張（隣接シフトとマージ）
  const [h, m] = timeHHmm.split(':').map(Number);
  const start = new Date(`${dateStr}T${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:00`);
  const end = new Date(start); end.setMinutes(end.getMinutes() + 15);

  if (!window._workShiftsOfDay) window._workShiftsOfDay = [];
  const shifts = window._workShiftsOfDay.filter(s => s.employeeCode === employeeCode);

  // ヘルパー: ISO比較
  const iso = d => new Date(d).toISOString();
  const startIso = iso(start);
  const endIso = iso(end);

  // 既存シフトに結合できるか確認
  let merged = false;
  for (const s of shifts) {
    if (iso(s.endAt) === startIso) {
      // 後ろに連結
      s.endAt = endIso;
      merged = true;
      break;
    }
    if (iso(s.startAt) === endIso) {
      // 前に連結
      s.startAt = startIso;
      merged = true;
      break;
    }
  }
  if (!merged) {
    window._workShiftsOfDay.push({
      employeeCode,
      startAt: startIso,
      endAt: endIso,
      employeeName: (workCell && workCell.closest('.grid-row')) ? '' : ''
    });
  } else {
    // 連結後、さらに隣のシフトとマージ可能かチェック
    let changed = true;
    while (changed) {
      changed = false;
      const empShifts = window._workShiftsOfDay.filter(s => s.employeeCode === employeeCode).sort((a,b)=>new Date(a.startAt)-new Date(b.startAt));
      for (let i=1;i<empShifts.length;i++){
        if (iso(empShifts[i-1].endAt) === iso(empShifts[i].startAt)){
          empShifts[i-1].endAt = empShifts[i].endAt;
          // remove i
          const idx = window._workShiftsOfDay.indexOf(empShifts[i]);
          if (idx >= 0) window._workShiftsOfDay.splice(idx,1);
          changed = true;
          break;
        }
      }
    }
  }
}

// 右クリックメニュー処理
function handleRightClick(event) {
  event.preventDefault();
  hideContextMenu();
  
  const cell = event.currentTarget;
  const isAssigned = cell.classList.contains('assigned');
  
  showContextMenu(event.pageX, event.pageY, cell, isAssigned);
}

function showContextMenu(x, y, cell, isAssigned) {
  contextMenu = document.createElement('div');
  contextMenu.className = 'context-menu show';
  
  if (isAssigned) {
    // 割り当て済みセル用メニュー
    contextMenu.innerHTML = `
      <button class="context-menu-item" data-action="change-register">
        <i class="bi bi-gear"></i> レジ変更
      </button>
      <div class="context-menu-divider"></div>
      <button class="context-menu-item danger" data-action="remove-assignment">
        <i class="bi bi-trash"></i> 割り当て解除
      </button>
    `;
  } else {
    // 未割り当てセル用メニュー
    const employeeName = cell.dataset.employeeName;
    contextMenu.innerHTML = `
      <button class="context-menu-item" data-action="assign-register">
        <i class="bi bi-plus-circle"></i> ${employeeName}に割り当て
      </button>
    `;
  }
  
  // イベントリスナーを追加
  contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
    item.addEventListener('click', (e) => {
      const action = e.target.closest('.context-menu-item').dataset.action;
      handleContextMenuAction(action, cell);
      hideContextMenu();
    });
  });
  
  // 位置を調整
  contextMenu.style.left = x + 'px';
  contextMenu.style.top = y + 'px';
  
  document.body.appendChild(contextMenu);
  
  // 外側クリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', closeContextMenuOnOutsideClick);
  }, 10);
}

function hideContextMenu() {
  if (contextMenu) {
    contextMenu.remove();
    contextMenu = null;
    document.removeEventListener('click', closeContextMenuOnOutsideClick);
  }
}

function closeContextMenuOnOutsideClick(event) {
  if (contextMenu && !contextMenu.contains(event.target)) {
    hideContextMenu();
  }
}

function handleContextMenuAction(action, cell) {
  switch (action) {
    case 'change-register':
      showRegisterSelectorForCell(cell);
      break;
    case 'remove-assignment':
      removeAssignment(cell);
      break;
    case 'assign-register':
      showRegisterSelectorForCell(cell);
      break;
  }
}

// 割り当て移動処理
function moveAssignmentToEmployee(assignment, targetEmployeeCode, targetTime) {
  const sourceCell = assignment.sourceCell;
  const targetCell = document.querySelector(`.grid-cell[data-employee="${targetEmployeeCode}"][data-time="${targetTime}"]`);
  
  if (!targetCell) return;
  
  // ターゲットセルが既に割り当て済みの場合は確認
  if (targetCell.classList.contains('assigned')) {
    const targetEmployeeName = targetCell.dataset.employeeName;
    const sourceEmployeeName = assignment.assignedEmployeeName;
    if (!confirm(`${targetEmployeeName}の${targetTime}は既に割り当てられています。${sourceEmployeeName}の割り当てで上書きしますか？`)) {
      return;
    }
  }
  
  // 元のセルから割り当てを削除（変更を追跡して保存時に削除される）
  const sourceEmployeeCode = sourceCell.dataset.employee;
  const sourceTime = sourceCell.dataset.time;
  const sourceOriginalValue = sourceCell.dataset.originalRegister || '';
  const sourceKey = `${sourceEmployeeCode}_${sourceTime}`;
  
  // 元のセルの削除を変更として追跡
  changes.set(sourceKey, {
    employeeCode: sourceEmployeeCode,
    time: sourceTime,
    original: sourceOriginalValue,
    current: ''
  });
  
  // 元のセルの表示をクリア
  sourceCell.classList.remove('assigned', 'color-0', 'color-1', 'color-2', 'color-3', 'color-4');
  sourceCell.classList.add('modified');
  sourceCell.textContent = '';
  sourceCell.dataset.currentRegister = '';
  sourceCell.draggable = false;
  sourceCell.removeEventListener('dragstart', handleAssignmentDragStart);
  sourceCell.removeEventListener('dragend', handleAssignmentDragEnd);
  delete sourceCell.dataset.assignedEmployeeName;
  
  // 新しいセルに割り当てを追加
  assignRegisterToCell(targetCell, assignment.registerNo, assignment.assignedEmployeeName);
  
  hasChanges = true;
  showSaveButtons();
}

function removeAssignment(cell) {
  const employeeCode = cell.dataset.employee;
  const time = cell.dataset.time;
  const originalValue = cell.dataset.originalRegister || '';
  const currentValue = cell.dataset.currentRegister || '';
  const key = `${employeeCode}_${time}`;
  
  // 既存の変更を確認
  const existingChange = changes.get(key);
  
  if (originalValue) {
    // 元々割り当てがあった場合は削除として記録
    changes.set(key, {
      employeeCode,
      time,
      original: originalValue,
      current: ''
    });
    hasChanges = true;
  } else if (existingChange && existingChange.original === '') {
    // 新規作成したものを削除する場合は変更履歴から削除
    changes.delete(key);
    hasChanges = changes.size > 0;
  } else if (existingChange) {
    // その他の変更がある場合は削除として記録
    changes.set(key, {
      employeeCode,
      time,
      original: existingChange.original,
      current: ''
    });
    hasChanges = true;
  }
  
  // セルから割り当てを削除
  cell.classList.remove('assigned', 'break-assigned', 'color-0', 'color-1', 'color-2', 'color-3', 'color-4');
  
  if (hasChanges) {
    cell.classList.add('modified');
    showSaveButtons();
  } else {
    cell.classList.remove('modified');
    hideSaveButtons();
  }
  
  // 作業モデル、人時過不足、勤務時間を更新
  updateWorkModel();
  updateStaffingBalance();
  updateWorkHours();
  
  cell.textContent = '';
  cell.dataset.currentRegister = '';
  cell.draggable = false;
  cell.removeEventListener('dragstart', handleAssignmentDragStart);
  cell.removeEventListener('dragend', handleAssignmentDragEnd);
  delete cell.dataset.assignedEmployeeName;
}


function showSaveButtons() {
  $('saveChangesBtn').style.display = 'inline-block';
  $('cancelChangesBtn').style.display = 'inline-block';
}

function hideSaveButtons() {
  $('saveChangesBtn').style.display = 'none';
  $('cancelChangesBtn').style.display = 'none';
}

// 保存・キャンセルボタンの処理
$('saveChangesBtn').onclick = saveChanges;
$('cancelChangesBtn').onclick = cancelChanges;

async function saveChanges() {
  if (!hasChanges) return;
  
  // 変更データを準備
  const changesArray = Array.from(changes.values());
  const date = $('date').value;
  
  try {
    $('saveChangesBtn').innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>保存中...';
    $('saveChangesBtn').disabled = true;
    
    const response = await fetch('/shift/api/calc/assignments/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        storeCode: $('storeCode').value,
        date: date,
        changes: changesArray
      })
    });
    
    if (!response.ok) {
      throw new Error(`保存に失敗しました: ${response.statusText}`);
    }
    
    // 成功時の処理
    changes.clear();
    hasChanges = false;
    hideSaveButtons();
    
    // 変更マークを削除
    document.querySelectorAll('.modified').forEach(cell => {
      cell.classList.remove('modified');
      cell.dataset.originalRegister = cell.dataset.currentRegister || '';
    });
    
    alert('変更が保存されました。');
    
  } catch (error) {
    console.error('Save error:', error);
    alert('保存中にエラーが発生しました: ' + error.message);
  } finally {
    $('saveChangesBtn').innerHTML = '<i class="bi bi-floppy"></i> 変更を保存';
    $('saveChangesBtn').disabled = false;
  }
}

function cancelChanges() {
  if (!hasChanges) return;
  
  if (confirm('変更をキャンセルしますか？')) {
    // 全ての変更を元に戻す
    changes.forEach((change, key) => {
      const [employeeCode, time] = key.split('_');
      const cell = document.querySelector(`.grid-cell[data-employee="${employeeCode}"][data-time="${time}"]`);
      if (cell) {
        cell.classList.remove('modified');
        cell.dataset.currentRegister = change.original;
        
        // 全ての割り当て関連クラスとイベントを削除
        cell.classList.remove('assigned', 'break-assigned', 'color-0', 'color-1', 'color-2', 'color-3', 'color-4');
        cell.draggable = false;
        cell.removeEventListener('dragstart', handleAssignmentDragStart);
        cell.removeEventListener('dragend', handleAssignmentDragEnd);
        
        if (change.original) {
          // 元の割り当てを復元
          cell.classList.add('assigned');
          
          if (change.original === 'break') {
            // 休憩の場合
            cell.classList.add('break-assigned');
            cell.textContent = '';
          } else {
            // レジ割り当ての場合
            cell.textContent = `R${change.original}`;
            
            // 元の従業員名を使って色を復元
            const originalEmployeeName = cell.dataset.assignedEmployeeName || cell.dataset.employeeName;
            const colorClass = getEmployeeColorClass(originalEmployeeName);
            cell.classList.add(colorClass);
          }
          
          // ドラッグ機能を復元（重複イベント防止）
          cell.draggable = true;
          cell.removeEventListener('dragstart', handleAssignmentDragStart);
          cell.removeEventListener('dragend', handleAssignmentDragEnd);
          cell.addEventListener('dragstart', handleAssignmentDragStart);
          cell.addEventListener('dragend', handleAssignmentDragEnd);
        } else {
          // 元が未割り当ての場合
          cell.textContent = '';
          delete cell.dataset.assignedEmployeeName;
        }
      }
    });
    
    changes.clear();
    hasChanges = false;
    hideSaveButtons();
  }
}

// 今日ボタンの処理
$('btnToday').onclick=()=>{
  const today = new Date().toISOString().split('T')[0];
  $('date').value = today;
  loadResult(today);
};

// スクロール同期機能（常にON）
let isScrolling = false;

function setupScrollSync() {
  const staffingBalanceContainer = $('staffingBalanceContainer');
  const workModelContainer = $('workModelContainer');
  const shiftContainer = $('tableContainer');
  
  const containers = [staffingBalanceContainer, workModelContainer, shiftContainer].filter(c => c);
  
  if (containers.length === 0) return;
  
  // 各コンテナのスクロールイベントを設定
  containers.forEach((container, index) => {
    container.addEventListener('scroll', function() {
      if (isScrolling) return;
      isScrolling = true;
      
      // 他のコンテナのスクロール位置を同期
      containers.forEach((otherContainer, otherIndex) => {
        if (index !== otherIndex) {
          otherContainer.scrollLeft = this.scrollLeft;
        }
      });
      
      setTimeout(() => { isScrolling = false; }, 50);
    });
  });
}

$('btnSearch').onclick=async()=>{
  const d=$('date').value;
  if(!d){alert('日付を選択してください');return;}
  loadResult(d);
};

$('btnPrevDay').onclick=()=>{
  const currentDate = $('date').value;
  if(!currentDate){
    alert('日付を選択してください');
    return;
  }
  const date = new Date(currentDate);
  date.setDate(date.getDate() - 1);
  const newDate = date.toISOString().split('T')[0];
  $('date').value = newDate;
  loadResult(newDate);
};

$('btnNextDay').onclick=()=>{
  const currentDate = $('date').value;
  if(!currentDate){
    alert('日付を選択してください');
    return;
  }
  const date = new Date(currentDate);
  date.setDate(date.getDate() + 1);
  const newDate = date.toISOString().split('T')[0];
  $('date').value = newDate;
  loadResult(newDate);
};

async function loadResult(dateString){
  let data;
  let employees;
  let workTimeMonthly = [];
  
  try {
    // 表示日付を更新
    const displayDate = new Date(dateString);
    const formattedDate = displayDate.toLocaleDateString('ja-JP', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric', 
      weekday: 'long' 
    });
    $('displayDate').textContent = formattedDate;
    
    const storeCode = $('storeCode').value;
    
    // 並行してデータを取得
    const [shiftData, employeeData, workTimeMonthlyResp] = await Promise.all([
      fetch(`/shift/api/calc/assignments/daily/${dateString}?storeCode=${encodeURIComponent(storeCode)}`).then(r=>r.json()),
      fetch(`/shift/api/calc/employees/${storeCode}`).then(r=>r.json()),
      // 月次の勤務時間（シフト）を取得し、当日分にフィルタして利用
      fetch(`/shift/api/calc/shifts/monthly/${dateString.substring(0,7)}?storeCode=${encodeURIComponent(storeCode)}`).then(r=>r.json())
    ]);
    
    data = shiftData;
    employees = employeeData;
    workTimeMonthly = workTimeMonthlyResp || [];
    
    const shiftGrid = $('shiftGrid');
    const noDataMessage = $('noDataMessage');
    const tableContainer = $('tableContainer');
    
    shiftGrid.innerHTML = ''; // Clear previous content
    
    if (employees && employees.length > 0) {
      noDataMessage.style.display = 'none';
      tableContainer.style.display = 'block';
      $('dragDropHelp').style.display = 'block';
      
      // 作業モデルと人時過不足データも同時に取得・表示
      loadWorkModel(dateString, data);
      loadStaffingBalance(dateString);
    } else {
      noDataMessage.style.display = 'block';
      tableContainer.style.display = 'none';
      $('dragDropHelp').style.display = 'none';
      $('workModelCard').style.display = 'none';
      $('staffingBalanceCard').style.display = 'none';
      return;
    }
  } catch (error) {
    console.error('データ取得エラー:', error);
    $('noDataMessage').style.display = 'block';
    $('tableContainer').style.display = 'none';
    $('dragDropHelp').style.display = 'none';
    $('workModelCard').style.display = 'none';
    $('staffingBalanceCard').style.display = 'none';
    return;
  }

  // 15分間隔の時間ヘッダーを作成
  const timeHeaderRow = document.createElement('div');
  timeHeaderRow.className = 'grid-row';
  timeHeaderRow.style.gridColumn = '1 / -1';
  timeHeaderRow.style.display = 'contents';

  const emptyHeader = document.createElement('div');
  emptyHeader.className = 'grid-header';
  emptyHeader.textContent = '従業員';
  timeHeaderRow.appendChild(emptyHeader);

  for (let h = 0; h < 24; h++) {
    for (let m = 0; m < 60; m += 15) {
      const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
      const timeHeader = document.createElement('div');
      timeHeader.className = 'grid-header time-slot';
      timeHeader.textContent = time;
      timeHeaderRow.appendChild(timeHeader);
    }
  }
  shiftGrid.appendChild(timeHeaderRow);

  // 従業員ごとの行を作成（シフト割り当て行 + 勤務時間行）
  employees.forEach(employee => {
    // シフト割り当て行のヘッダー
    const employeeRowHeader = document.createElement('div');
    employeeRowHeader.className = 'grid-row-header';
    employeeRowHeader.innerHTML = `
      <div class="employee-name">${employee.employeeName}</div>
      <div class="employee-code">${employee.employeeCode}</div>
    `;
    
    shiftGrid.appendChild(employeeRowHeader);

    // シフト割り当てセル
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += 15) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell employee-shift-cell drop-zone';
        cell.dataset.employee = employee.employeeCode;
        cell.dataset.employeeName = employee.employeeName;
        cell.dataset.time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        cell.dataset.originalRegister = '';
        
        // イベントを追加
        cell.addEventListener('dragover', handleDragOver);
        cell.addEventListener('drop', handleDrop);
        cell.addEventListener('dragleave', handleDragLeave);
        cell.addEventListener('contextmenu', handleRightClick);
        
        shiftGrid.appendChild(cell);
      }
    }
    
    // 勤務時間表示行のヘッダー
    const workHoursHeader = document.createElement('div');
    workHoursHeader.className = 'grid-row-header';
    workHoursHeader.style.fontSize = '0.7rem';
    workHoursHeader.textContent = '勤務時間';
    
    shiftGrid.appendChild(workHoursHeader);
    
    // 勤務時間表示セル
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += 15) {
        const workHoursCell = document.createElement('div');
        workHoursCell.className = 'grid-cell work-hours-cell';
        workHoursCell.dataset.employee = employee.employeeCode;
        workHoursCell.dataset.time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        
        shiftGrid.appendChild(workHoursCell);
      }
    }
  });

  // 勤務時間（workTimeMonthly）で勤務行に薄色を塗る（レジ割当がなくても勤務中なら表示）
  if (workTimeMonthly && workTimeMonthly.length > 0) {
    const dayOnly = dateString; // 'YYYY-MM-DD'
    const workShiftsOfDay = workTimeMonthly.filter(s => {
      const d = new Date(s.startAt);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}` === dayOnly;
    });

    // グローバルに保持して、集計表示でも使う
    window._workShiftsOfDay = workShiftsOfDay;

    workShiftsOfDay.forEach(shift => {
      const start = new Date(shift.startAt);
      const end = new Date(shift.endAt);
      let cur = new Date(start);
      while (cur < end) {
        const hour = cur.getHours();
        const minute = cur.getMinutes();
        const targetTime = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        const cell = document.querySelector(`.work-hours-cell[data-employee="${shift.employeeCode}"][data-time="${targetTime}"]`);
        if (cell) cell.classList.add('working');
        cur.setMinutes(cur.getMinutes() + 15);
      }
    });
  } else {
    window._workShiftsOfDay = [];
  }

  // シフト割り当てデータでセルを塗りつぶし
  if (data && data.length > 0) {
    data.forEach(assignment => {
      const start = new Date(assignment.startAt);
      const end = new Date(assignment.endAt);
      const colorClass = getEmployeeColorClass(assignment.employeeName);

      // 15分間隔でセルを塗りつぶし
      let currentTime = new Date(start);
      while (currentTime < end) {
        const hour = currentTime.getHours();
        const minute = currentTime.getMinutes();
        const targetTime = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;

        const cell = shiftGrid.querySelector(`.employee-shift-cell[data-employee="${assignment.employeeCode}"][data-time="${targetTime}"]`);
        if (cell) {
          cell.classList.add('assigned');
          
          const registerValue = assignment.registerNo;
          if (registerValue === 'break' || assignment.registerNo === 0) {
            // 休憩の場合
            cell.classList.add('break-assigned');
            cell.textContent = '';
            cell.dataset.originalRegister = 'break';
            cell.dataset.currentRegister = 'break';
          } else {
            // レジ割り当ての場合
            cell.classList.add(colorClass);
            cell.textContent = `R${assignment.registerNo}`;
            cell.dataset.originalRegister = assignment.registerNo;
            cell.dataset.currentRegister = assignment.registerNo;
          }
          
          // 従業員名を正しく設定（APIからの名前またはセルの従業員名を使用）
          const employeeName = assignment.employeeName || cell.dataset.employeeName;
          cell.dataset.assignedEmployeeName = employeeName;
          
          // 割り当てセルをドラッグ可能にする（重複イベント防止）
          cell.draggable = true;
          cell.removeEventListener('dragstart', handleAssignmentDragStart);
          cell.removeEventListener('dragend', handleAssignmentDragEnd);
          cell.addEventListener('dragstart', handleAssignmentDragStart);
          cell.addEventListener('dragend', handleAssignmentDragEnd);
        }
        currentTime.setMinutes(currentTime.getMinutes() + 15);
      }
    });
  }
  
  // スクロール同期をセットアップ
  setupScrollSync();
  
  // 勤務時間を計算・表示（勤務行の背景・合計時間ラベルなど）
  updateWorkHours();
}

async function loadStaffingBalance(dateString) {
  try {
    const storeCode = $('storeCode').value;
    const staffingData = await fetch(`/shift/api/calc/staffing-balance/${dateString}?storeCode=${encodeURIComponent(storeCode)}`).then(r => r.json());
    const staffingGrid = $('staffingBalanceGrid');
    const staffingCard = $('staffingBalanceCard');
    
    staffingGrid.innerHTML = ''; // Clear previous content
    console.log('Staffing balance data:', staffingData); // デバッグ用
    
    if (staffingData && staffingData.length > 0) {
      staffingCard.style.display = 'block';
      
      // ヘッダー行を作成（必要・配置・差分の3行）
      const headers = ['必要人数', '配置人数', '過不足'];
      
      headers.forEach(headerText => {
        // 行ヘッダー
        const rowHeader = document.createElement('div');
        rowHeader.className = 'grid-row-header';
        rowHeader.textContent = headerText;
        staffingGrid.appendChild(rowHeader);
        
        // 15分間隔の時間スロット
        for (let h = 0; h < 24; h++) {
          for (let m = 0; m < 60; m += 15) {
            const targetTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:00`;
            
            // 該当する時間帯のデータを検索
            const balanceData = staffingData.find(data => {
              if (!data.slotTime) return false;
              const timeStr = typeof data.slotTime === 'string' ? data.slotTime : 
                             (data.slotTime.hour !== undefined ? 
                              `${String(data.slotTime.hour).padStart(2, '0')}:${String(data.slotTime.minute).padStart(2, '0')}:00` : 
                              data.slotTime.toString());
              return timeStr === targetTime;
            });
            
            const cell = document.createElement('div');
            cell.className = 'grid-cell staffing-balance-cell';
            
            if (balanceData) {
              const required = balanceData.requiredStaff || 0;
              const assigned = balanceData.assignedStaff || 0;
              const balance = assigned - required;
              
              if (headerText === '必要人数') {
                cell.textContent = required;
                if (required > 0) {
                  cell.style.background = '#e3f2fd';
                  cell.style.color = '#1565c0';
                }
              } else if (headerText === '配置人数') {
                cell.textContent = assigned;
                if (assigned > 0) {
                  cell.style.background = '#f3e5f5';
                  cell.style.color = '#7b1fa2';
                }
              } else if (headerText === '過不足') {
                if (balance < 0) {
                  cell.classList.add('shortage');
                  cell.innerHTML = `<div class="balance-value">${balance}</div><div class="balance-detail">不足</div>`;
                } else if (balance > 0) {
                  cell.classList.add('excess');
                  cell.innerHTML = `<div class="balance-value">+${balance}</div><div class="balance-detail">超過</div>`;
                } else if (required > 0) {
                  cell.classList.add('balanced');
                  cell.innerHTML = `<div class="balance-value">0</div><div class="balance-detail">適正</div>`;
                } else {
                  cell.textContent = '-';
                }
              }
            } else {
              cell.textContent = '-';
            }
            
            staffingGrid.appendChild(cell);
          }
        }
      });
      
      // 人時過不足用のCSSグリッドを設定（15分間隔と同じ）
      staffingGrid.style.gridTemplateColumns = '120px repeat(96, 50px)';
      staffingGrid.style.gridTemplateRows = 'repeat(3, 35px)';
    } else {
      staffingCard.style.display = 'none';
    }
  } catch (error) {
    console.error('人時過不足データ取得エラー:', error);
    $('staffingBalanceCard').style.display = 'none';
  }
}

async function loadWorkModel(dateString, shiftData) {
  try {
    const storeCode = $('storeCode').value;
    const workModelData = await fetch(`/shift/api/calc/work-model-quarter/${dateString}?storeCode=${encodeURIComponent(storeCode)}`).then(r => r.json());
    const workModelGrid = $('workModelGrid');
    const workModelCard = $('workModelCard');
    
    workModelGrid.innerHTML = ''; // Clear previous content
    console.log('Work model data:', workModelData); // デバッグ用
    console.log('Shift data for work model:', shiftData); // デバッグ用
    
    if (workModelData && workModelData.length > 0) {
      workModelCard.style.display = 'block';
      
      // 15分間隔の時間ヘッダーを作成（シフト表示と同じ）
      const timeHeaderRow = document.createElement('div');
      timeHeaderRow.className = 'grid-row';
      timeHeaderRow.style.gridColumn = '1 / -1';
      timeHeaderRow.style.display = 'contents';

      const emptyHeader = document.createElement('div');
      emptyHeader.className = 'grid-header';
      emptyHeader.textContent = '時間';
      timeHeaderRow.appendChild(emptyHeader);

      for (let h = 0; h < 24; h++) {
        for (let m = 0; m < 60; m += 15) {
          const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
          const timeHeader = document.createElement('div');
          timeHeader.className = 'grid-header time-slot';
          timeHeader.textContent = time;
          timeHeaderRow.appendChild(timeHeader);
        }
      }
      workModelGrid.appendChild(timeHeaderRow);

      // 最大レジ台数を計算
      const maxDemand = Math.max(...workModelData.map(d => d.requiredUnits || 0), 1);
      
      // 各時間帯での需要データを事前に処理
      const demandByTime = new Map();
      for (let h = 0; h < 24; h++) {
        for (let m = 0; m < 60; m += 15) {
          const targetTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:00`;
          const quarterData = workModelData.find(d => {
            if (!d.slotTime) return false;
            const timeStr = typeof d.slotTime === 'string' ? d.slotTime : 
                           (d.slotTime.hour !== undefined ? 
                            `${String(d.slotTime.hour).padStart(2, '0')}:${String(d.slotTime.minute).padStart(2, '0')}:00` : 
                            d.slotTime.toString());
            return timeStr === targetTime;
          });
          const demandCount = quarterData ? (quarterData.requiredUnits || 0) : 0;
          demandByTime.set(`${h}_${m}`, demandCount);
        }
      }
      
      // シフトデータから時間・レジごとの従業員マッピングを作成
      const employeeByTimeRegister = new Map();
      if (shiftData && shiftData.length > 0) {
        shiftData.forEach(assignment => {
          const start = new Date(assignment.startAt);
          const end = new Date(assignment.endAt);
          const employeeName = assignment.employeeName || assignment.employeeCode;
          const registerNo = assignment.registerNo;
          
          // 15分間隔でマッピングを作成
          let currentTime = new Date(start);
          while (currentTime < end) {
            const hour = currentTime.getHours();
            const minute = currentTime.getMinutes();
            const key = `${hour}_${minute}_${registerNo}`;
            employeeByTimeRegister.set(key, employeeName);
            currentTime.setMinutes(currentTime.getMinutes() + 15);
          }
        });
      }

      // レジ番号の行を作成（レジ1からmaxDemandまで）
      for (let registerNo = 1; registerNo <= maxDemand; registerNo++) {
        const registerRowHeader = document.createElement('div');
        registerRowHeader.className = 'grid-row-header';
        registerRowHeader.textContent = `レジ ${registerNo}`;
        workModelGrid.appendChild(registerRowHeader);

        for (let h = 0; h < 24; h++) {
          for (let m = 0; m < 60; m += 15) {
            const demandCount = demandByTime.get(`${h}_${m}`) || 0;
            
            // この時間帯にこのレジ番号が必要な場合のみセルを作成
            if (registerNo <= demandCount) {
              const cell = document.createElement('div');
              cell.className = 'grid-cell work-model-cell register-needed';
              
              // 割り当てられた従業員名を取得
              const employeeKey = `${h}_${m}_${registerNo}`;
              const employeeName = employeeByTimeRegister.get(employeeKey);
              
              if (employeeName) {
                // 従業員名の頭2文字を表示
                const shortName = employeeName.length >= 2 ? employeeName.substring(0, 2) : employeeName;
                cell.textContent = shortName;
                cell.classList.add('has-employee');
              }
              
              workModelGrid.appendChild(cell);
            } else {
              // 不要な場合は空のdivを作成（グリッドレイアウト維持のため）
              const emptyCell = document.createElement('div');
              emptyCell.className = 'grid-cell work-model-cell-empty';
              workModelGrid.appendChild(emptyCell);
            }
          }
        }
      }
      
      // 作業モデル用のCSSグリッドを設定（15分間隔と同じ）
      workModelGrid.style.gridTemplateColumns = '120px repeat(96, 50px)';
    } else {
      workModelCard.style.display = 'none';
    }
  } catch (error) {
    console.error('作業モデルデータ取得エラー:', error);
    $('workModelCard').style.display = 'none';
  }
}

// 現在の割り当て状況で作業モデルを更新
function updateWorkModel() {
  // 現在のシフトデータを収集
  const currentShiftData = [];
  const shiftCells = document.querySelectorAll('.grid-cell.assigned[data-current-register]');
  
  shiftCells.forEach(cell => {
    const employeeCode = cell.dataset.employee;
    const employeeName = cell.dataset.assignedEmployeeName || cell.dataset.employeeName;
    const time = cell.dataset.time;
    const registerNo = parseInt(cell.dataset.currentRegister);
    
    if (registerNo && time) {
      const [hour, minute] = time.split(':').map(Number);
      const startAt = new Date();
      startAt.setHours(hour, minute, 0, 0);
      const endAt = new Date(startAt);
      endAt.setMinutes(endAt.getMinutes() + 15);
      
      currentShiftData.push({
        employeeCode,
        employeeName,
        registerNo,
        startAt: startAt.toISOString(),
        endAt: endAt.toISOString()
      });
    }
  });
  
  // 作業モデルのセルを更新
  const workModelCells = document.querySelectorAll('.work-model-cell.register-needed');
  
  // 従業員マッピングを再作成
  const employeeByTimeRegister = new Map();
  currentShiftData.forEach(assignment => {
    const start = new Date(assignment.startAt);
    const hour = start.getHours();
    const minute = start.getMinutes();
    const key = `${hour}_${minute}_${assignment.registerNo}`;
    employeeByTimeRegister.set(key, assignment.employeeName);
  });
  
  // 各セルを更新
  let cellIndex = 0;
  const workModelGrid = $('workModelGrid');
  if (!workModelGrid) return;
  
  // 作業モデルのグリッド構造を仮定してセルを更新
  const workModelData = document.querySelectorAll('.work-model-cell.register-needed');
  
  // 現在表示されている作業モデルを基に更新
  for (let registerNo = 1; registerNo <= 10; registerNo++) { // 最大レジ数を仮定
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += 15) {
        const cell = workModelData[cellIndex];
        if (cell) {
          const employeeKey = `${h}_${m}_${registerNo}`;
          const employeeName = employeeByTimeRegister.get(employeeKey);
          
          cell.classList.remove('has-employee');
          cell.textContent = '';
          
          if (employeeName) {
            const shortName = employeeName.length >= 2 ? employeeName.substring(0, 2) : employeeName;
            cell.textContent = shortName;
            cell.classList.add('has-employee');
          }
          
          cellIndex++;
        }
      }
    }
  }
}

// 現在の割り当て状況で人時過不足を更新
function updateStaffingBalance() {
  const staffingGrid = $('staffingBalanceGrid');
  if (!staffingGrid) return;
  
  // 現在のシフトデータを収集
  const currentShiftData = [];
  const shiftCells = document.querySelectorAll('.grid-cell.assigned[data-current-register]');
  
  shiftCells.forEach(cell => {
    const employeeCode = cell.dataset.employee;
    const time = cell.dataset.time;
    const registerNo = parseInt(cell.dataset.currentRegister);
    
    if (registerNo && time) {
      const [hour, minute] = time.split(':').map(Number);
      currentShiftData.push({
        employeeCode,
        time: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`
      });
    }
  });
  
  // 時間帯別の配置人数をカウント
  const assignedCountsByTime = new Map();
  currentShiftData.forEach(assignment => {
    const timeKey = assignment.time;
    assignedCountsByTime.set(timeKey, (assignedCountsByTime.get(timeKey) || 0) + 1);
  });
  
  // 過不足行（3行目）のセルを更新
  const balanceCells = staffingGrid.querySelectorAll('.grid-cell');
  
  // 3行目の過不足セルのみ更新（0から始まるインデックスで2行目）
  const rowSize = 97; // ヘッダー1 + 時間スロット96
  const balanceRowStartIndex = rowSize * 2; // 3行目の開始インデックス
  
  for (let i = 0; i < 96; i++) { // 96の時間スロット
    const cellIndex = balanceRowStartIndex + 1 + i; // +1はヘッダー分
    const cell = balanceCells[cellIndex];
    
    if (cell) {
      const h = Math.floor(i / 4);
      const m = (i % 4) * 15;
      const targetTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:00`;
      
      // 元の必要人数を取得（データから）
      const requiredCell = balanceCells[1 + i]; // 1行目の対応するセル
      const required = requiredCell ? parseInt(requiredCell.textContent) || 0 : 0;
      
      // 現在の配置人数を取得
      const assigned = assignedCountsByTime.get(targetTime) || 0;
      
      // 配置人数行（2行目）を更新
      const assignedCell = balanceCells[rowSize + 1 + i];
      if (assignedCell) {
        assignedCell.textContent = assigned;
        if (assigned > 0) {
          assignedCell.style.background = '#f3e5f5';
          assignedCell.style.color = '#7b1fa2';
        } else {
          assignedCell.style.background = '#f8f9fa';
          assignedCell.style.color = '#6c757d';
        }
      }
      
      // 過不足を計算して更新
      const balance = assigned - required;
      
      // セルのクラスをリセット
      cell.classList.remove('shortage', 'excess', 'balanced');
      
      if (balance < 0) {
        cell.classList.add('shortage');
        cell.innerHTML = `<div class="balance-value">${balance}</div><div class="balance-detail">不足</div>`;
      } else if (balance > 0) {
        cell.classList.add('excess');
        cell.innerHTML = `<div class="balance-value">+${balance}</div><div class="balance-detail">超過</div>`;
      } else if (required > 0) {
        cell.classList.add('balanced');
        cell.innerHTML = `<div class="balance-value">0</div><div class="balance-detail">適正</div>`;
      } else {
        cell.textContent = '-';
      }
    }
  }
}

// 勤務時間を計算・表示する関数
function updateWorkHours() {
  const employees = document.querySelectorAll('.employee-shift-cell');
  if (employees.length === 0) return;
  
  // 従業員コードごとにグループ化
  const employeeCodes = new Set();
  employees.forEach(cell => { if (cell.dataset.employee) employeeCodes.add(cell.dataset.employee); });
  
  employeeCodes.forEach(employeeCode => {
    // この従業員の割り当てセルを取得
    const assignmentCells = document.querySelectorAll(`.employee-shift-cell[data-employee="${employeeCode}"]`);
    const workHoursCells = document.querySelectorAll(`.work-hours-cell[data-employee="${employeeCode}"]`);
    
    // 勤務時間スロットを勤務シフト（_workShiftsOfDay）から構成
    const timeSlots = new Map(); // time -> { working: boolean }
    const workByEmp = (window._workShiftsOfDay || []).filter(s => s.employeeCode === employeeCode);
    workByEmp.forEach(shift => {
      let cur = new Date(shift.startAt);
      const end = new Date(shift.endAt);
      while (cur < end) {
        const hh = String(cur.getHours()).padStart(2,'0');
        const mm = String(cur.getMinutes()).padStart(2,'0');
        timeSlots.set(`${hh}:${mm}`, { working: true });
        cur.setMinutes(cur.getMinutes() + 15);
      }
    });
    
    // 勤務時間セルを更新
    workHoursCells.forEach(cell => {
      const time = cell.dataset.time;
      const status = timeSlots.get(time);
      
      // セルをクリア
      cell.textContent = '';
      if (status && status.working) {
        cell.classList.add('working');
      } else {
        cell.classList.remove('working');
      }
    });
    
    // 連続勤務時間の計算（休憩を除く）
    calculateContinuousWorkPeriods(employeeCode, timeSlots, workHoursCells);
  });
}

// 連続勤務時間を計算して表示
function calculateContinuousWorkPeriods(employeeCode, timeSlots, workHoursCells) {
  const times = Array.from(timeSlots.keys()).sort();
  let workPeriods = [];
  let currentPeriod = null;
  
  times.forEach(time => {
    const status = timeSlots.get(time);
    
    if (status && status.working) {
      // 勤務時間
      if (!currentPeriod) {
        currentPeriod = { start: time, end: time, duration: 15 };
      } else {
        currentPeriod.end = time;
        currentPeriod.duration += 15;
      }
    } else {
      // 未割り当てまたは休憩
      if (currentPeriod) {
        workPeriods.push(currentPeriod);
        currentPeriod = null;
      }
    }
  });
  
  // 最後の期間を追加
  if (currentPeriod) {
    workPeriods.push(currentPeriod);
  }
  
  // 勤務時間の表示を更新（開始時間のみ表示、期間が長い場合は時間数も表示）
  workHoursCells.forEach(cell => {
    const time = cell.dataset.time;
    const status = timeSlots.get(time);
    
    if (status && status.assigned && !status.break) {
      // この時間が勤務期間の開始かどうかチェック
      const period = workPeriods.find(p => p.start === time);
      if (period) {
        const hours = Math.floor(period.duration / 60);
        const minutes = period.duration % 60;
        
        if (hours > 0) {
          cell.textContent = `${hours}h${minutes > 0 ? minutes + 'm' : ''}`;
        } else {
          cell.textContent = `${minutes}m`;
        }
      }
    }
  });
}
</script>
</div>
</body>
</html>
