<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout}">
<head>
  <title>日次シフト表示</title>
</head>
<body>
<div layout:fragment="content">
  <div class="content-header">
    <h1><i class="bi bi-calendar-day"></i> 日次シフト表示</h1>
    <p class="mb-0">日別のシフト割り当て結果を確認できます</p>
  </div>

<div class="row g-4">
  <!-- Control Panel -->
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0"><i class="bi bi-sliders"></i> 表示設定</h5>
      </div>
      <div class="card-body">
        <div class="row g-3 align-items-end">
          <div class="col-md-3">
            <label class="form-label fw-semibold">
              <i class="bi bi-calendar-day me-1"></i>表示日
            </label>
            <input type="date" id="date" class="form-control form-control-lg">
          </div>
          <div class="col-md-3">
            <label class="form-label fw-semibold">
              <i class="bi bi-shop me-1"></i>店舗
            </label>
            <select id="storeCode" class="form-select form-select-lg">
              <option value="">店舗を選択</option>
              <option th:each="store : ${stores}"
                      th:value="${store.storeCode}"
                      th:text="${store.storeCode} + ' - ' + ${store.storeName}">
              </option>
            </select>
          </div>
          <div class="col-md-3">
            <label class="form-label fw-semibold">
              <i class="bi bi-diagram-3 me-1"></i>部門
            </label>
            <select id="departmentCode" class="form-select form-select-lg">
              <option value="">部門を選択</option>
            </select>
          </div>
          <div class="col-md-3">
            <div class="btn-group w-100" role="group">
              <button id="btnPrevDay" class="btn btn-outline-primary">
                <i class="bi bi-chevron-left"></i> 前日
              </button>
              <button id="btnSearch" class="btn btn-primary">
                <i class="bi bi-search"></i> 検索
              </button>
              <button id="btnNextDay" class="btn btn-outline-primary">
                翌日 <i class="bi bi-chevron-right"></i>
              </button>
            </div>
          </div>
          <div class="col-md-3">
            <button id="btnToday" class="btn btn-success w-100">
              <i class="bi bi-calendar-today"></i> 今日
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Hard Constraint Violation Alert -->
<div class="row g-4" id="constraintAlertContainer" style="display: none;">
  <div class="col-12">
    <div class="alert alert-danger" role="alert">
      <div class="d-flex align-items-start">
        <i class="bi bi-exclamation-triangle-fill me-3" style="font-size: 1.5rem; margin-top: 0.125rem;"></i>
        <div class="flex-grow-1">
          <h5 class="alert-heading mb-2">⚠️ ハード制約違反が検出されました</h5>
          <div id="constraintViolationMessages"></div>
          <hr class="my-3">
          <p class="mb-0">
            <strong>対処方法:</strong> 上記の制約違反を解決してから再度最適化を実行してください。
            制約違反がある状態では結果を保存できません。
          </p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Staffing Balance Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="staffingBalanceCard" style="display: none;">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-graph-up-arrow me-2"></i>時間帯別人時過不足
        </h5>
      </div>
      <div class="card-body p-0">
        <div class="table-responsive" id="staffingBalanceContainer" style="max-height: 250px; overflow-x: auto; overflow-y: auto;">
          <div id="staffingBalanceGrid" class="grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Work Model Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="workModelCard" style="display: none;">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-bar-chart me-2"></i>作業モデル（必要レジ台数）
        </h5>
      </div>
      <div class="card-body p-0">
        <div class="table-responsive" id="workModelContainer" style="max-height: 400px; overflow-x: auto; overflow-y: auto;">
          <div id="workModelGrid" class="grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Department Workload Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="departmentWorkCard" style="display: none;">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-clipboard-data me-2"></i>部門別作業量（作業計画）
        </h5>
      </div>
      <div class="card-body p-0">
        <div class="table-responsive" id="departmentWorkContainer" style="max-height: 400px; overflow-x: auto; overflow-y: auto;">
          <div id="departmentWorkGrid" class="grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Results Section -->
<div class="row g-4 mt-2">
  <div class="col-12">
    <div class="card" id="resultsCard">
      <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">
          <i class="bi bi-table me-2"></i>シフト割り当て結果
        </h5>
        <div class="d-flex align-items-center gap-3">
          <div class="text-muted small" id="displayDate">
            表示日を選択してください
          </div>
          <button id="btnRunAssignmentForDay" class="btn btn-primary btn-sm" title="この日の作業割当を再計算して保存">
            <i class="bi bi-cpu"></i> 作業割当
          </button>
          <button id="saveChangesBtn" class="btn btn-success btn-sm" style="display: none;">
            <i class="bi bi-floppy"></i> 変更を保存
          </button>
          <button id="cancelChangesBtn" class="btn btn-secondary btn-sm" style="display: none;">
            <i class="bi bi-x-circle"></i> キャンセル
          </button>
        </div>
      </div>
      <div class="card-body p-0">
        <div class="alert alert-info m-3" id="dragDropHelp">
          <div class="d-flex align-items-start">
            <i class="bi bi-info-circle me-2 mt-1"></i>
            <div>
              <strong>使い方:</strong><br>
              <div class="mt-2">
                <span class="badge bg-primary me-2">ドラッグ</span> 割り当て済みセルを他の従業員の同じ時間にドラッグして移動<br>
                <span class="badge bg-success me-2">右クリック</span> セルを右クリックで割り当て・変更・解除メニュー
              </div>
            </div>
          </div>
        </div>
        <div id="noDataMessage" class="text-center py-5 text-muted">
          <i class="bi bi-calendar-x display-4 d-block mb-3"></i>
          <h6>シフトデータがありません</h6>
          <p class="mb-0">日付を選択して検索ボタンを押してください</p>
        </div>
        <div class="table-responsive" style="max-height: 600px; overflow-x: auto; overflow-y: auto; display: none;" id="tableContainer">
          <div id="shiftGrid" class="grid-container shift-grid-container"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* Shift-specific grid layout */
  .shift-grid-container {
    /* grid-template-columns は解像度(RES_MIN)に応じてJSで動的設定 */
    grid-auto-rows: 32px;
    align-items: stretch;
    grid-auto-flow: row;
  }

  #tableContainer,
  #workModelContainer,
  #departmentWorkContainer,
  #staffingBalanceContainer {
    border: 1px solid #dee2e6;
    border-radius: 6px;
    background: #fff;
  }

  .shift-grid-container .grid-cell,
  #workModelGrid .grid-cell,
  #departmentWorkGrid .grid-cell,
  #staffingBalanceGrid .grid-cell {
    border-right: 1px solid #f0f0f0;
    border-bottom: 1px solid #f7f7f7;
    min-height: 28px;
    position: relative;
    box-sizing: border-box;
  }

  .shift-grid-container .grid-header,
  .shift-grid-container .grid-cell {
    padding: 2px 4px;
    line-height: 1.1;
    box-sizing: border-box;
  }

  .shift-grid-container .grid-cell:not(.assigned):hover {
    background: #f1f5ff;
  }

  .shift-grid-container .grid-row-header {
    position: sticky;
    left: 0;
    background: #f8f9fa;
    border-right: 1px solid #dee2e6;
    z-index: 5;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: #6c757d;
    flex-direction: column;
    gap: 1px;
    padding: 2px 4px;
    overflow: hidden;
    box-sizing: border-box;
  }

  .shift-grid-container .grid-row-header .employee-name {
    color: #212529;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .shift-grid-container .grid-row-header .employee-code {
    color: #6c757d;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .shift-grid-container .grid-header,
  #workModelGrid .grid-header,
  #departmentWorkGrid .grid-header,
  #staffingBalanceGrid .grid-header {
    position: sticky;
    top: 0;
    background: #f8f9fa;
    z-index: 6;
    border-bottom: 1px solid #dee2e6;
    font-size: 12px;
    color: #6c757d;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
  }

  .shift-grid-container .grid-header.time-slot,
  #workModelGrid .grid-header.time-slot,
  #departmentWorkGrid .grid-header.time-slot,
  #staffingBalanceGrid .grid-header.time-slot {
    border-right: 1px solid #eee;
  }

  .shift-grid-container .employee-shift-cell {
    background: #fff;
  }

  .assignment-block {
    border-radius: 3px;
    font-weight: 600;
    font-size: 0.7rem;
    text-align: center;
    padding: 2px 4px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    z-index: 1;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
  }

  .assignment-block.assigned {
    color: #fff;
  }

  .assignment-block.color-0 { background: var(--color-stock); }
  .assignment-block.color-1 { background: var(--color-clean); }
  .assignment-block.color-2 { background: var(--color-register); }
  .assignment-block.color-3 { background: var(--color-orange); }
  .assignment-block.color-4 { background: var(--color-default); }

  .assignment-block.task-assigned {
    background: #6c757d;
    color: #fff;
    border-left: 3px solid #495057;
  }

  .assignment-block.break-assigned {
    background: var(--color-default);
    color: #fff;
    border: 1px solid var(--color-default);
  }
  
  /* Register selector (shift-specific) */
  .register-selector {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #007bff;
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 1000;
    display: none;
  }
  
  .register-selector.show {
    display: block;
  }
  
  /* Drag grip icon */
  .grid-cell.assigned[draggable="true"]:hover::after {
    content: "\\f47a"; /* Bootstrap grip icon */
    font-family: "Bootstrap Icons";
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 0.6rem;
    color: rgba(255,255,255,0.7);
  }
  /* Department task (non-register) assignment style */
  .grid-cell.task-assigned {
    background: #6c757d;
    color: #fff;
    font-weight: 600;
    border-left: 3px solid #495057;
    display: flex;
    align-items: center;
    justify-content: center;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
  }

  /* Work-hours row (attendance shading) */
  .work-hours-cell {
    position: relative;
    background: transparent;
    border-top: 1px dashed #e9ecef;
  }
  .work-hours-cell.working {
    background: rgba(13, 110, 253, 0.15); /* bootstrap primary tint */
  }

  /* Department workload grid */
  .department-work-cell {
    background: rgba(69, 183, 209, 0.12);
    color: #0f3d47;
    font-weight: 600;
    text-align: center;
  }
  .department-work-cell.has-demand {
    border-left: 2px solid rgba(69, 183, 209, 0.6);
  }
  .department-work-cell-empty {
    background: #f8f9fa;
  }
  .dept-plan-block {
    border-radius: 3px;
    color: #fff;
    font-weight: 600;
    font-size: 0.7rem;
    text-align: center;
    padding: 2px 4px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    z-index: 4;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    pointer-events: none;
  }
</style>

<script th:inline="javascript">
const $=id=>document.getElementById(id);

// 時間解像度（分）とスロット数（24h）
const RES_MIN = /*[[${timeResolutionMinutes}]]*/ 15;
const SLOT_COUNT = Math.floor(1440 / RES_MIN);
const PER_HOUR = Math.floor(60 / RES_MIN);

// 編集状態管理
let isEditing = false;
let hasChanges = false;
let changes = new Map(); // key: employeeCode_time, value: {original, current}
let employees = [];
let taskMasterList = [];

function gridColumnIndex(h, m) {
  return (h * PER_HOUR) + (m / RES_MIN) + 2;
}

function setGridPosition(el, row, col) {
  el.style.gridRow = String(row);
  el.style.gridColumn = String(col);
}

function createTimeHeaderRow(grid, label) {
  const timeHeaderRow = document.createElement('div');
  timeHeaderRow.className = 'grid-row';
  timeHeaderRow.style.display = 'contents';

  const emptyHeader = document.createElement('div');
  emptyHeader.className = 'grid-header';
  emptyHeader.textContent = label;
  setGridPosition(emptyHeader, 1, 1);
  timeHeaderRow.appendChild(emptyHeader);

  for (let h = 0; h < 24; h++) {
    for (let m = 0; m < 60; m += RES_MIN) {
      const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
      const timeHeader = document.createElement('div');
      timeHeader.className = 'grid-header time-slot';
      timeHeader.textContent = m === 0 ? time : '';
      setGridPosition(timeHeader, 1, gridColumnIndex(h, m));
      timeHeaderRow.appendChild(timeHeader);
    }
  }
  grid.appendChild(timeHeaderRow);
}

function buildTimeSlots() {
  const timeSlots = [];
  for (let h = 0; h < 24; h++) {
    for (let m = 0; m < 60; m += RES_MIN) {
      timeSlots.push(`${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`);
    }
  }
  return timeSlots;
}

function selectedDepartmentCode() {
  const code = $('departmentCode') ? $('departmentCode').value : '';
  return code && code.trim() ? code.trim() : '520';
}

function isRegisterDepartment() {
  const code = $('departmentCode') ? $('departmentCode').value : '';
  return !code || code === '520';
}

function encodeTaskValue(departmentCode, taskCode) {
  return `TASK|${departmentCode || ''}|${taskCode || ''}`;
}

function parseTaskValue(value) {
  if (!value || !value.startsWith('TASK|')) return null;
  const parts = value.split('|');
  return {
    departmentCode: parts[1] || '',
    taskCode: parts[2] || ''
  };
}

// Function to generate a consistent color based on employee name
function getEmployeeColorClass(employeeName) {
  if (!employeeName) {
    return 'color-4';
  }
  let hash = 0;
  for (let i = 0; i < employeeName.length; i++) {
    hash = employeeName.charCodeAt(i) + ((hash << 5) - hash);
  }
  return `color-${Math.abs(hash) % 5}`; // Use 5 distinct colors
}

function getTaskDisplayColor(taskCode) {
  if (!taskCode) return '#95a5a6';
  if (taskCode.includes('REG') || taskCode.includes('レジ')) return '#ff6b6b';
  if (taskCode.includes('STOCK') || taskCode.includes('品出し')) return '#4ecdc4';
  if (taskCode.includes('CLEAN') || taskCode.includes('清掃')) return '#45b7d1';
  return '#95a5a6';
}

const taskNameByCode = new Map();

function getTaskName(taskCode, departmentCode) {
  if (!taskCode) return '作業';
  const deptKey = `${departmentCode || ''}::${taskCode}`;
  return taskNameByCode.get(deptKey) || taskNameByCode.get(`::${taskCode}`) || taskCode;
}

async function loadTaskMasterMap(storeCode, departmentCode) {
  if (!storeCode) return;
  try {
    const res = await fetch(`/shift/api/calc/task-masters?storeCode=${encodeURIComponent(storeCode)}${departmentCode ? `&departmentCode=${encodeURIComponent(departmentCode)}` : ''}`);
    const list = await res.json();
    taskMasterList = Array.isArray(list) ? list : [];
    taskNameByCode.clear();
    taskMasterList.forEach(t => {
      const key = `${t.departmentCode || ''}::${t.taskCode}`;
      taskNameByCode.set(key, t.name || t.taskCode || '');
      if (!t.departmentCode) {
        taskNameByCode.set(`::${t.taskCode}`, t.name || t.taskCode || '');
      }
    });
  } catch (e) {
    console.error('作業マスタ取得エラー:', e);
    taskNameByCode.clear();
    taskMasterList = [];
  }
}

// ドラッグアンドドロップと右クリックメニュー処理
let draggedAssignment = null;
let registerSelector = null;
let taskSelector = null;
let contextMenu = null;

// 割り当てセルのドラッグ処理
function handleAssignmentDragStart(event) {
  const cell = event.target;
  const isTask = cell.classList.contains('task-assigned') || cell.classList.contains('break-assigned');
  draggedAssignment = {
    sourceCell: cell,
    employeeCode: cell.dataset.employee,
    employeeName: cell.dataset.employeeName,
    time: cell.dataset.time,
    registerNo: isTask ? '' : cell.dataset.currentRegister,
    taskCode: isTask ? cell.dataset.taskCode : '',
    departmentCode: isTask ? cell.dataset.departmentCode : '',
    type: isTask ? 'task' : 'register',
    assignedEmployeeName: cell.dataset.assignedEmployeeName
  };
  
  cell.classList.add('dragging');
  event.dataTransfer.effectAllowed = 'move';
  event.dataTransfer.setData('text/plain', '');
}

function handleAssignmentDragEnd(event) {
  event.target.classList.remove('dragging');
  draggedAssignment = null;
  
  // 全てのdrag-overクラスを削除
  document.querySelectorAll('.drag-over').forEach(cell => {
    cell.classList.remove('drag-over');
  });
  
  hideContextMenu();
}

// 店舗変更で部門一覧をロード
document.addEventListener('DOMContentLoaded', () => {
  const storeSelect = $('storeCode');
  const deptSelect = $('departmentCode');
  async function loadDepartments() {
    const storeCode = storeSelect.value;
    if (!storeCode) { deptSelect.innerHTML = '<option value="">部門を選択</option>'; return; }
    try {
      const list = await fetch(`/shift/api/departments/${encodeURIComponent(storeCode)}`).then(r=>r.json());
      deptSelect.innerHTML = '<option value="">部門を選択</option>' +
        list.map(d => `<option value="${d.departmentCode}">${d.departmentCode} - ${d.departmentName||''}</option>`).join('');
    } catch (e) {
      console.error('部門取得に失敗', e);
      deptSelect.innerHTML = '<option value="">部門を選択</option>';
    }
  }
  if (storeSelect) {
    storeSelect.addEventListener('change', loadDepartments);
    // 初期状態（未選択）では部門はプレースホルダのみにする
    loadDepartments();
  }

  // 単日作業割当の実行ボタン
  const runBtn = $('btnRunAssignmentForDay');
  if (runBtn) {
    runBtn.addEventListener('click', async () => {
      const date = $('date').value;
      const storeCode = $('storeCode').value;
      const departmentCode = $('departmentCode').value || '';
      if (!date || !storeCode) {
        alert('日付と店舗を選択してください');
        return;
      }
      runBtn.disabled = true;
      const prevHtml = runBtn.innerHTML;
      runBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status"></span> 実行中...';
      try {
        const res = await fetch('/shift/api/assignment/start-day', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ date, storeCode, departmentCode })
        }).then(r => r.json());
        if (!res.success) throw new Error(res.error || '実行に失敗しました');
        // 再読込
        await loadResult(date);
        // 成功通知
        const ok = document.createElement('div');
        ok.className = 'alert alert-success m-3';
        ok.textContent = '作業割当を実行し、結果を保存しました。';
        const card = document.getElementById('resultsCard');
        if (card) card.insertBefore(ok, card.firstChild);
        setTimeout(()=> ok.remove(), 2500);
      } catch (e) {
        console.error(e);
        alert('作業割当の実行に失敗しました: ' + e.message);
      } finally {
        runBtn.disabled = false;
        runBtn.innerHTML = prevHtml;
      }
    });
  }
});

function handleDragOver(event) {
  if (!draggedAssignment) return;
  
  event.preventDefault();
  event.dataTransfer.dropEffect = 'move';
  
  const cell = event.currentTarget;
  const targetEmployee = cell.dataset.employee;
  const sourceEmployee = draggedAssignment.employeeCode;
  
  // 異なる従業員のセルのみドロップ可能
  if (targetEmployee !== sourceEmployee) {
    cell.classList.add('drag-over');
  }
}

function handleDragLeave(event) {
  const cell = event.currentTarget;
  cell.classList.remove('drag-over');
}

function handleDrop(event) {
  event.preventDefault();
  
  if (!draggedAssignment) return;
  
  const cell = event.currentTarget;
  cell.classList.remove('drag-over');
  
  const targetEmployee = cell.dataset.employee;
  const sourceEmployee = draggedAssignment.employeeCode;
  const targetTime = draggedAssignment.time;
  
  // 異なる従業員への移動のみ許可
  if (targetEmployee !== sourceEmployee) {
    moveAssignmentToEmployee(draggedAssignment, targetEmployee, targetTime);
  }
}

function showRegisterSelectorForCell(cell) {
  hideRegisterSelector();
  
  const currentRegister = cell.dataset.currentRegister || '';
  
  // レジスターセレクターを作成
  registerSelector = document.createElement('div');
  registerSelector.className = 'register-selector show';
  registerSelector.innerHTML = `
    <div class="mb-2"><strong>レジを選択:</strong></div>
    <div class="btn-group-vertical" role="group">
      <button type="button" class="btn btn-outline-secondary btn-sm" data-register="">未割当</button>
      <button type="button" class="btn btn-outline-info btn-sm" data-register="break">休憩</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="1">レジ1</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="2">レジ2</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="3">レジ3</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="4">レジ4</button>
      <button type="button" class="btn btn-outline-primary btn-sm" data-register="5">レジ5</button>
    </div>
  `;
  
  // 現在のレジが選択されている場合はハイライト
  const currentButton = registerSelector.querySelector(`[data-register="${currentRegister}"]`);
  if (currentButton) {
    currentButton.classList.remove('btn-outline-primary', 'btn-outline-secondary');
    currentButton.classList.add('btn-primary');
  }
  
  // イベントリスナーを追加
  registerSelector.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const registerValue = e.target.dataset.register;
      assignRegisterToCell(cell, registerValue);
      hideRegisterSelector();
    });
  });
  
  // セルに配置
  cell.style.position = 'relative';
  cell.appendChild(registerSelector);
  
  // 外側クリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', closeRegisterSelectorOnOutsideClick);
  }, 10);
}

function hideRegisterSelector() {
  if (registerSelector) {
    registerSelector.remove();
    registerSelector = null;
    document.removeEventListener('click', closeRegisterSelectorOnOutsideClick);
  }
}

function closeRegisterSelectorOnOutsideClick(event) {
  if (registerSelector && !registerSelector.contains(event.target)) {
    hideRegisterSelector();
  }
}

function resetAssignmentCell(cell) {
  cell.classList.remove('assigned', 'break-assigned', 'task-assigned', 'modified', 'color-0', 'color-1', 'color-2', 'color-3', 'color-4');
  cell.textContent = '';
  cell.dataset.currentRegister = '';
  cell.dataset.workKind = '';
  cell.dataset.registerLabel = '';
  cell.dataset.taskCode = '';
  cell.dataset.departmentCode = '';
  cell.dataset.taskLabel = '';
  delete cell.dataset.assignedEmployeeName;
  cell.draggable = false;
  cell.removeEventListener('dragstart', handleAssignmentDragStart);
  cell.removeEventListener('dragend', handleAssignmentDragEnd);
}

function applyRegisterValue(cell, registerValue, assignedEmployeeName = null) {
  resetAssignmentCell(cell);
  if (!registerValue) return;
  const employeeNameForColor = assignedEmployeeName || cell.dataset.employeeName;
  cell.classList.add('assigned');
  if (registerValue === 'break') {
    cell.classList.add('break-assigned');
    cell.dataset.workKind = 'BREAK';
    cell.dataset.registerLabel = '休';
  } else {
    const colorClass = getEmployeeColorClass(employeeNameForColor);
    cell.classList.add(colorClass);
    cell.dataset.workKind = 'REGISTER_OP';
    cell.dataset.registerLabel = `R${registerValue}`;
  }
  cell.dataset.taskCode = '';
  cell.dataset.departmentCode = '';
  cell.dataset.taskLabel = '';
  cell.dataset.assignedEmployeeName = employeeNameForColor;
  cell.dataset.currentRegister = registerValue;
  cell.draggable = true;
  cell.addEventListener('dragstart', handleAssignmentDragStart);
  cell.addEventListener('dragend', handleAssignmentDragEnd);
}

function applyTaskValue(cell, taskCode, departmentCode, assignedEmployeeName = null) {
  resetAssignmentCell(cell);
  if (!taskCode) return;
  const deptCode = departmentCode || selectedDepartmentCode();
  const employeeNameForColor = assignedEmployeeName || cell.dataset.employeeName;
  const taskLabel = taskCode === 'BREAK' ? '休憩' : getTaskName(taskCode, deptCode);
  if (taskCode === 'BREAK') {
    cell.classList.add('break-assigned');
    cell.dataset.workKind = 'BREAK';
    cell.dataset.registerLabel = '休';
  } else {
    cell.classList.add('task-assigned');
    cell.dataset.workKind = 'DEPARTMENT_TASK';
    cell.dataset.registerLabel = '';
  }
  cell.dataset.taskCode = taskCode;
  cell.dataset.departmentCode = deptCode;
  cell.dataset.taskLabel = taskLabel;
  cell.dataset.assignedEmployeeName = employeeNameForColor;
  cell.dataset.currentRegister = encodeTaskValue(deptCode, taskCode);
  cell.draggable = true;
  cell.addEventListener('dragstart', handleAssignmentDragStart);
  cell.addEventListener('dragend', handleAssignmentDragEnd);
}

function showTaskSelectorForCell(cell) {
  hideTaskSelector();
  hideRegisterSelector();

  const deptCode = selectedDepartmentCode();
  const tasks = (taskMasterList || []).filter(t => {
    const tDept = t.departmentCode || '';
    if (!deptCode || deptCode === '520') {
      return tDept === '' || tDept === deptCode;
    }
    return tDept === deptCode;
  });
  const options = tasks.map(t => {
    const label = t.name ? `${t.taskCode} - ${t.name}` : t.taskCode;
    const optionDept = t.departmentCode || deptCode;
    return `<option value="${optionDept}::${t.taskCode}">${label}</option>`;
  }).join('');

  taskSelector = document.createElement('div');
  taskSelector.className = 'register-selector show';
  taskSelector.innerHTML = `
    <div class="mb-2"><strong>作業を選択:</strong></div>
    <select class="form-select form-select-sm mb-2" id="taskSelectorSelect">
      <option value="">未割当</option>
      <option value="BREAK">休憩</option>
      ${options}
    </select>
    <div class="d-flex gap-2">
      <button type="button" class="btn btn-primary btn-sm" data-action="apply">設定</button>
      <button type="button" class="btn btn-outline-secondary btn-sm" data-action="close">閉じる</button>
    </div>
  `;

  taskSelector.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      if (action === 'apply') {
        const select = taskSelector.querySelector('#taskSelectorSelect');
        const value = select ? select.value : '';
        if (!value) {
          assignTaskToCell(cell, '', deptCode);
        } else if (value.includes('::')) {
          const [taskDept, taskCode] = value.split('::');
          assignTaskToCell(cell, taskCode || '', taskDept || deptCode);
        } else {
          assignTaskToCell(cell, value, deptCode);
        }
      }
      hideTaskSelector();
    });
  });

  cell.style.position = 'relative';
  cell.appendChild(taskSelector);

  setTimeout(() => {
    document.addEventListener('click', closeTaskSelectorOnOutsideClick);
  }, 10);
}

function hideTaskSelector() {
  if (taskSelector) {
    taskSelector.remove();
    taskSelector = null;
    document.removeEventListener('click', closeTaskSelectorOnOutsideClick);
  }
}

function closeTaskSelectorOnOutsideClick(event) {
  if (taskSelector && !taskSelector.contains(event.target)) {
    hideTaskSelector();
  }
}

function assignRegisterToCell(cell, newValue, assignedEmployeeName = null) {
  if (newValue === 'break') {
    assignTaskToCell(cell, 'BREAK', selectedDepartmentCode(), assignedEmployeeName);
    return;
  }
  const employeeCode = cell.dataset.employee;
  const time = cell.dataset.time;
  const originalValue = cell.dataset.originalRegister || '';
  const key = `${employeeCode}_${time}`;
  
  if (newValue !== originalValue) {
    // 変更があった場合
    changes.set(key, {
      employeeCode,
      time,
      original: originalValue,
      current: newValue
    });
    
    cell.dataset.currentRegister = newValue;
    applyRegisterValue(cell, newValue, assignedEmployeeName);
    cell.classList.add('modified');
    if (newValue) {
      try {
        addWorkingSlot(cell.dataset.employee, cell.dataset.time);
      } catch(e) { console.warn('addWorkingSlot failed', e); }
    }
    
    hasChanges = true;
    showSaveButtons();
    
    // 作業モデル、人時過不足、勤務時間を更新
    updateWorkModel();
    updateStaffingBalance();
    updateWorkHours();
    renderMergedAssignments();
  } else {
    // 変更なし（元の状態に復元）
    if (newValue) {
      applyRegisterValue(cell, newValue, assignedEmployeeName);
    } else {
      resetAssignmentCell(cell);
    }
    changes.delete(key);
    cell.classList.remove('modified');
    if (changes.size === 0) {
      hasChanges = false;
      hideSaveButtons();
    }
    updateWorkModel();
    updateStaffingBalance();
    updateWorkHours();
    renderMergedAssignments();
  }
}

function assignTaskToCell(cell, taskCode, departmentCode, assignedEmployeeName = null) {
  const employeeCode = cell.dataset.employee;
  const time = cell.dataset.time;
  const originalValue = cell.dataset.originalRegister || '';
  const deptCode = departmentCode || selectedDepartmentCode();
  const newValue = taskCode ? encodeTaskValue(deptCode, taskCode) : '';
  const key = `${employeeCode}_${time}`;

  if (newValue !== originalValue) {
    changes.set(key, {
      employeeCode,
      time,
      original: originalValue,
      current: newValue
    });

    cell.dataset.currentRegister = newValue;
    applyTaskValue(cell, taskCode, deptCode, assignedEmployeeName);
    cell.classList.add('modified');
    if (taskCode) {
      cell.dataset.currentRegister = newValue;
    }

    hasChanges = true;
    showSaveButtons();
    updateWorkModel();
    updateStaffingBalance();
    updateWorkHours();
    renderMergedAssignments();
  } else {
    if (taskCode) {
      applyTaskValue(cell, taskCode, deptCode, assignedEmployeeName);
    } else {
      resetAssignmentCell(cell);
    }
    changes.delete(key);
    cell.classList.remove('modified');
    if (changes.size === 0) {
      hasChanges = false;
      hideSaveButtons();
    }
    updateWorkModel();
    updateStaffingBalance();
    updateWorkHours();
    renderMergedAssignments();
  }
}

// 指定の従業員・時刻(HH:mm)のスロットを勤務時間として取り込む
function addWorkingSlot(employeeCode, timeHHmm) {
  const dateStr = document.getElementById('date').value; // YYYY-MM-DD
  if (!dateStr) return;

  // work-hours セルに薄色背景を付与
  const workCell = document.querySelector(`.work-hours-cell[data-employee="${employeeCode}"][data-time="${timeHHmm}"]`);
  if (workCell) workCell.classList.add('working');

  // _workShiftsOfDay をスロットで拡張（隣接シフトとマージ）
  const [h, m] = timeHHmm.split(':').map(Number);
  const start = new Date(`${dateStr}T${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:00`);
  const end = new Date(start); end.setMinutes(end.getMinutes() + RES_MIN);

  if (!window._workShiftsOfDay) window._workShiftsOfDay = [];
  const shifts = window._workShiftsOfDay.filter(s => s.employeeCode === employeeCode);

  // ヘルパー: ISO比較
  const iso = d => new Date(d).toISOString();
  const startIso = iso(start);
  const endIso = iso(end);

  // 既存シフトに結合できるか確認
  let merged = false;
  for (const s of shifts) {
    if (iso(s.endAt) === startIso) {
      // 後ろに連結
      s.endAt = endIso;
      merged = true;
      break;
    }
    if (iso(s.startAt) === endIso) {
      // 前に連結
      s.startAt = startIso;
      merged = true;
      break;
    }
  }
  if (!merged) {
    window._workShiftsOfDay.push({
      employeeCode,
      startAt: startIso,
      endAt: endIso,
      employeeName: (workCell && workCell.closest('.grid-row')) ? '' : ''
    });
  } else {
    // 連結後、さらに隣のシフトとマージ可能かチェック
    let changed = true;
    while (changed) {
      changed = false;
      const empShifts = window._workShiftsOfDay.filter(s => s.employeeCode === employeeCode).sort((a,b)=>new Date(a.startAt)-new Date(b.startAt));
      for (let i=1;i<empShifts.length;i++){
        if (iso(empShifts[i-1].endAt) === iso(empShifts[i].startAt)){
          empShifts[i-1].endAt = empShifts[i].endAt;
          // remove i
          const idx = window._workShiftsOfDay.indexOf(empShifts[i]);
          if (idx >= 0) window._workShiftsOfDay.splice(idx,1);
          changed = true;
          break;
        }
      }
    }
  }
}

function buildAssignmentKey(cell) {
  if (!cell) return null;
  if (cell.classList.contains('task-assigned')) {
    return `TASK::${cell.dataset.departmentCode || ''}::${cell.dataset.taskCode || ''}`;
  }
  if (cell.classList.contains('break-assigned')) {
    return 'BREAK';
  }
  if (cell.classList.contains('assigned')) {
    return `REG::${cell.dataset.currentRegister || ''}`;
  }
  return null;
}

function buildAssignmentLabel(cell) {
  if (!cell) return '';
  if (cell.classList.contains('task-assigned')) {
    return cell.dataset.taskLabel || (cell.dataset.taskCode || '作業');
  }
  if (cell.classList.contains('break-assigned')) {
    return cell.dataset.registerLabel || '休';
  }
  if (cell.classList.contains('assigned')) {
    return cell.dataset.registerLabel || '';
  }
  return '';
}

function renderMergedAssignments() {
  const shiftGrid = $('shiftGrid');
  if (!shiftGrid || !Array.isArray(employees) || employees.length === 0) return;
  shiftGrid.querySelectorAll('.assignment-block').forEach(block => block.remove());

  employees.forEach((employee, employeeIndex) => {
    const rowIndex = 2 + (employeeIndex * 2);
    let currentKey = null;
    let currentLabel = '';
    let currentClasses = [];
    let segmentStart = null;

    for (let slot = 0; slot <= SLOT_COUNT; slot++) {
      let key = null;
      let label = '';
      let classList = [];
      if (slot < SLOT_COUNT) {
        const totalMinutes = slot * RES_MIN;
        const hour = Math.floor(totalMinutes / 60);
        const minute = totalMinutes % 60;
        const time = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        const cell = shiftGrid.querySelector(`.employee-shift-cell[data-employee="${employee.employeeCode}"][data-time="${time}"]`);
        key = buildAssignmentKey(cell);
        if (key) {
          label = buildAssignmentLabel(cell);
          classList = ['assignment-block'];
          if (cell.classList.contains('task-assigned')) {
            classList.push('task-assigned');
          } else if (cell.classList.contains('break-assigned')) {
            classList.push('break-assigned');
          } else if (cell.classList.contains('assigned')) {
            classList.push('assigned');
            ['color-0', 'color-1', 'color-2', 'color-3', 'color-4'].forEach(c => {
              if (cell.classList.contains(c)) classList.push(c);
            });
          }
          cell.textContent = '';
        }
      }

      if (key !== currentKey) {
        if (currentKey && segmentStart !== null) {
          const block = document.createElement('div');
          block.className = currentClasses.join(' ');
          block.textContent = currentLabel;
          block.style.gridRow = `${rowIndex}`;
          block.style.gridColumn = `${segmentStart + 2} / ${slot + 2}`;
          shiftGrid.appendChild(block);
        }
        if (key) {
          currentKey = key;
          currentLabel = label;
          currentClasses = classList;
          segmentStart = slot;
        } else {
          currentKey = null;
          currentLabel = '';
          currentClasses = [];
          segmentStart = null;
        }
      }
    }
  });
}

// 右クリックメニュー処理
function handleRightClick(event) {
  event.preventDefault();
  hideContextMenu();
  
  const cell = event.currentTarget;
  const isAssigned = cell.classList.contains('assigned') ||
    cell.classList.contains('task-assigned') ||
    cell.classList.contains('break-assigned');
  
  showContextMenu(event.pageX, event.pageY, cell, isAssigned);
}

function showContextMenu(x, y, cell, isAssigned) {
  contextMenu = document.createElement('div');
  contextMenu.className = 'context-menu show';
  const isTaskAssigned = cell.classList.contains('task-assigned') || cell.classList.contains('break-assigned');
  const registerMode = isRegisterDepartment();
  
  if (isAssigned) {
    // 割り当て済みセル用メニュー
    if (isTaskAssigned) {
      contextMenu.innerHTML = `
        <button class="context-menu-item" data-action="change-task">
          <i class="bi bi-gear"></i> 作業変更
        </button>
        <div class="context-menu-divider"></div>
        <button class="context-menu-item danger" data-action="remove-assignment">
          <i class="bi bi-trash"></i> 割り当て解除
        </button>
      `;
    } else {
      contextMenu.innerHTML = `
        <button class="context-menu-item" data-action="change-register">
          <i class="bi bi-gear"></i> レジ変更
        </button>
        <div class="context-menu-divider"></div>
        <button class="context-menu-item danger" data-action="remove-assignment">
          <i class="bi bi-trash"></i> 割り当て解除
        </button>
      `;
    }
  } else {
    // 未割り当てセル用メニュー
    const employeeName = cell.dataset.employeeName;
    if (registerMode) {
      contextMenu.innerHTML = `
        <button class="context-menu-item" data-action="assign-register">
          <i class="bi bi-plus-circle"></i> レジを割り当て
        </button>
        <button class="context-menu-item" data-action="assign-task">
          <i class="bi bi-plus-circle"></i> 作業を割り当て
        </button>
      `;
    } else {
      contextMenu.innerHTML = `
        <button class="context-menu-item" data-action="assign-task">
          <i class="bi bi-plus-circle"></i> ${employeeName}に割り当て
        </button>
      `;
    }
  }
  
  // イベントリスナーを追加
  contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
    item.addEventListener('click', (e) => {
      const action = e.target.closest('.context-menu-item').dataset.action;
      handleContextMenuAction(action, cell);
      hideContextMenu();
    });
  });
  
  // 位置を調整
  contextMenu.style.left = x + 'px';
  contextMenu.style.top = y + 'px';
  
  document.body.appendChild(contextMenu);
  
  // 外側クリックで閉じる
  setTimeout(() => {
    document.addEventListener('click', closeContextMenuOnOutsideClick);
  }, 10);
}

function hideContextMenu() {
  if (contextMenu) {
    contextMenu.remove();
    contextMenu = null;
    document.removeEventListener('click', closeContextMenuOnOutsideClick);
  }
}

function closeContextMenuOnOutsideClick(event) {
  if (contextMenu && !contextMenu.contains(event.target)) {
    hideContextMenu();
  }
}

function handleContextMenuAction(action, cell) {
  switch (action) {
    case 'change-register':
      showRegisterSelectorForCell(cell);
      break;
    case 'change-task':
      showTaskSelectorForCell(cell);
      break;
    case 'remove-assignment':
      removeAssignment(cell);
      break;
    case 'assign-register':
      showRegisterSelectorForCell(cell);
      break;
    case 'assign-task':
      showTaskSelectorForCell(cell);
      break;
  }
}

// 割り当て移動処理
function moveAssignmentToEmployee(assignment, targetEmployeeCode, targetTime) {
  const sourceCell = assignment.sourceCell;
  const targetCell = document.querySelector(`.grid-cell[data-employee="${targetEmployeeCode}"][data-time="${targetTime}"]`);
  
  if (!targetCell) return;
  
  // ターゲットセルが既に割り当て済みの場合は確認
  if (targetCell.classList.contains('assigned')) {
    const targetEmployeeName = targetCell.dataset.employeeName;
    const sourceEmployeeName = assignment.assignedEmployeeName;
    if (!confirm(`${targetEmployeeName}の${targetTime}は既に割り当てられています。${sourceEmployeeName}の割り当てで上書きしますか？`)) {
      return;
    }
  }
  
  // 元のセルから割り当てを削除（変更を追跡して保存時に削除される）
  const sourceEmployeeCode = sourceCell.dataset.employee;
  const sourceTime = sourceCell.dataset.time;
  const sourceOriginalValue = sourceCell.dataset.originalRegister || '';
  const sourceKey = `${sourceEmployeeCode}_${sourceTime}`;
  
  // 元のセルの削除を変更として追跡
  changes.set(sourceKey, {
    employeeCode: sourceEmployeeCode,
    time: sourceTime,
    original: sourceOriginalValue,
    current: ''
  });
  
  // 元のセルの表示をクリア
  resetAssignmentCell(sourceCell);
  sourceCell.classList.add('modified');
  
  // 新しいセルに割り当てを追加
  if (assignment.type === 'task') {
    assignTaskToCell(targetCell, assignment.taskCode, assignment.departmentCode, assignment.assignedEmployeeName);
  } else {
    assignRegisterToCell(targetCell, assignment.registerNo, assignment.assignedEmployeeName);
  }
  
  hasChanges = true;
  showSaveButtons();
  renderMergedAssignments();
}

function removeAssignment(cell) {
  const employeeCode = cell.dataset.employee;
  const time = cell.dataset.time;
  const originalValue = cell.dataset.originalRegister || '';
  const currentValue = cell.dataset.currentRegister || '';
  const key = `${employeeCode}_${time}`;
  
  // 既存の変更を確認
  const existingChange = changes.get(key);
  
  if (originalValue) {
    // 元々割り当てがあった場合は削除として記録
    changes.set(key, {
      employeeCode,
      time,
      original: originalValue,
      current: ''
    });
    hasChanges = true;
  } else if (existingChange && existingChange.original === '') {
    // 新規作成したものを削除する場合は変更履歴から削除
    changes.delete(key);
    hasChanges = changes.size > 0;
  } else if (existingChange) {
    // その他の変更がある場合は削除として記録
    changes.set(key, {
      employeeCode,
      time,
      original: existingChange.original,
      current: ''
    });
    hasChanges = true;
  }
  
  // セルから割り当てを削除
  resetAssignmentCell(cell);
  
  if (hasChanges) {
    cell.classList.add('modified');
    showSaveButtons();
  } else {
    cell.classList.remove('modified');
    hideSaveButtons();
  }
  
  // 作業モデル、人時過不足、勤務時間を更新
  updateWorkModel();
  updateStaffingBalance();
  updateWorkHours();
  renderMergedAssignments();
  
  cell.textContent = '';
}


function showSaveButtons() {
  $('saveChangesBtn').style.display = 'inline-block';
  $('cancelChangesBtn').style.display = 'inline-block';
}

function hideSaveButtons() {
  $('saveChangesBtn').style.display = 'none';
  $('cancelChangesBtn').style.display = 'none';
}

// 保存・キャンセルボタンの処理
$('saveChangesBtn').onclick = saveChanges;
$('cancelChangesBtn').onclick = cancelChanges;

async function saveChanges() {
  if (!hasChanges) return;
  
  // 変更データを準備
  const changesArray = Array.from(changes.values());
  const date = $('date').value;
  
  try {
    $('saveChangesBtn').innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>保存中...';
    $('saveChangesBtn').disabled = true;
    
    const response = await fetch('/shift/api/calc/assignments/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        storeCode: $('storeCode').value,
        date: date,
        changes: changesArray
      })
    });
    
    if (!response.ok) {
      throw new Error(`保存に失敗しました: ${response.statusText}`);
    }
    
    // 成功時の処理
    changes.clear();
    hasChanges = false;
    hideSaveButtons();
    
    // 変更マークを削除
    document.querySelectorAll('.modified').forEach(cell => {
      cell.classList.remove('modified');
      cell.dataset.originalRegister = cell.dataset.currentRegister || '';
    });
    
    alert('変更が保存されました。');
    
  } catch (error) {
    console.error('Save error:', error);
    alert('保存中にエラーが発生しました: ' + error.message);
  } finally {
    $('saveChangesBtn').innerHTML = '<i class="bi bi-floppy"></i> 変更を保存';
    $('saveChangesBtn').disabled = false;
  }
}

function cancelChanges() {
  if (!hasChanges) return;
  
  if (confirm('変更をキャンセルしますか？')) {
    // 全ての変更を元に戻す
    changes.forEach((change, key) => {
      const [employeeCode, time] = key.split('_');
      const cell = document.querySelector(`.grid-cell[data-employee="${employeeCode}"][data-time="${time}"]`);
      if (cell) {
        cell.classList.remove('modified');
        cell.dataset.currentRegister = change.original;
        
        // 全ての割り当て関連クラスとイベントを削除
        cell.classList.remove('assigned', 'break-assigned', 'task-assigned', 'color-0', 'color-1', 'color-2', 'color-3', 'color-4');
        cell.draggable = false;
        cell.removeEventListener('dragstart', handleAssignmentDragStart);
        cell.removeEventListener('dragend', handleAssignmentDragEnd);
        cell.dataset.workKind = '';
        cell.dataset.registerLabel = '';
        cell.dataset.taskCode = '';
        cell.dataset.departmentCode = '';
        cell.dataset.taskLabel = '';
        
        if (change.original) {
          const taskValue = parseTaskValue(change.original);
          if (taskValue) {
            const taskCode = taskValue.taskCode || '';
            const deptCode = taskValue.departmentCode || selectedDepartmentCode();
            const taskLabel = taskCode === 'BREAK' ? '休憩' : getTaskName(taskCode, deptCode);
            if (taskCode === 'BREAK') {
              cell.classList.add('break-assigned');
              cell.dataset.workKind = 'BREAK';
              cell.dataset.registerLabel = '休';
            } else {
              cell.classList.add('task-assigned');
              cell.dataset.workKind = 'DEPARTMENT_TASK';
              cell.dataset.registerLabel = '';
            }
            cell.textContent = '';
            cell.dataset.taskCode = taskCode;
            cell.dataset.departmentCode = deptCode;
            cell.dataset.taskLabel = taskLabel;
          } else {
            // 元の割り当てを復元（レジ）
            cell.classList.add('assigned');
            if (change.original === 'break') {
              // 休憩の場合
              cell.classList.add('break-assigned');
              cell.textContent = '';
              cell.dataset.workKind = 'BREAK';
              cell.dataset.registerLabel = '休';
            } else {
              // レジ割り当ての場合
              cell.textContent = '';
              cell.dataset.workKind = 'REGISTER_OP';
              cell.dataset.registerLabel = `R${change.original}`;
              const originalEmployeeName = cell.dataset.assignedEmployeeName || cell.dataset.employeeName;
              const colorClass = getEmployeeColorClass(originalEmployeeName);
              cell.classList.add(colorClass);
            }
            cell.dataset.taskCode = '';
            cell.dataset.departmentCode = '';
            cell.dataset.taskLabel = '';
          }

          cell.draggable = true;
          cell.removeEventListener('dragstart', handleAssignmentDragStart);
          cell.removeEventListener('dragend', handleAssignmentDragEnd);
          cell.addEventListener('dragstart', handleAssignmentDragStart);
          cell.addEventListener('dragend', handleAssignmentDragEnd);
        } else {
          // 元が未割り当ての場合
          cell.textContent = '';
          delete cell.dataset.assignedEmployeeName;
          cell.dataset.workKind = '';
          cell.dataset.registerLabel = '';
          cell.dataset.taskCode = '';
          cell.dataset.departmentCode = '';
          cell.dataset.taskLabel = '';
        }
      }
    });
    
    changes.clear();
    hasChanges = false;
    hideSaveButtons();
    renderMergedAssignments();
  }
}

// 今日ボタンの処理
$('btnToday').onclick=()=>{
  const today = new Date().toISOString().split('T')[0];
  $('date').value = today;
  loadResult(today);
};

// スクロール同期機能（常にON）
let isScrolling = false;

function setupScrollSync() {
  const staffingBalanceContainer = $('staffingBalanceContainer');
  const workModelContainer = $('workModelContainer');
  const departmentWorkContainer = $('departmentWorkContainer');
  const shiftContainer = $('tableContainer');
  
  const containers = [staffingBalanceContainer, workModelContainer, departmentWorkContainer, shiftContainer].filter(c => c);
  
  if (containers.length === 0) return;
  
  // 各コンテナのスクロールイベントを設定
  containers.forEach((container, index) => {
    container.addEventListener('scroll', function() {
      if (isScrolling) return;
      isScrolling = true;
      
      // 他のコンテナのスクロール位置を同期
      containers.forEach((otherContainer, otherIndex) => {
        if (index !== otherIndex) {
          otherContainer.scrollLeft = this.scrollLeft;
        }
      });
      
      setTimeout(() => { isScrolling = false; }, 50);
    });
  });
}

$('btnSearch').onclick=async()=>{
  const d=$('date').value;
  if(!d){alert('日付を選択してください');return;}
  loadResult(d);
};

$('btnPrevDay').onclick=()=>{
  const currentDate = $('date').value;
  if(!currentDate){
    alert('日付を選択してください');
    return;
  }
  const date = new Date(currentDate);
  date.setDate(date.getDate() - 1);
  const newDate = date.toISOString().split('T')[0];
  $('date').value = newDate;
  loadResult(newDate);
};

$('btnNextDay').onclick=()=>{
  const currentDate = $('date').value;
  if(!currentDate){
    alert('日付を選択してください');
    return;
  }
  const date = new Date(currentDate);
  date.setDate(date.getDate() + 1);
  const newDate = date.toISOString().split('T')[0];
  $('date').value = newDate;
  loadResult(newDate);
};

async function loadResult(dateString){
  let data;
  let workTimeMonthly = [];
  const shiftGrid = $('shiftGrid');
  const noDataMessage = $('noDataMessage');
  const tableContainer = $('tableContainer');
  
  try {
    // 表示日付を更新
    const displayDate = new Date(dateString);
    const formattedDate = displayDate.toLocaleDateString('ja-JP', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric', 
      weekday: 'long' 
    });
    $('displayDate').textContent = formattedDate;
    
    const storeCode = $('storeCode').value;
    const departmentCode = $('departmentCode').value || '';

    // 並行してデータを取得
    const [, shiftData, employeeData, workTimeMonthlyResp] = await Promise.all([
      loadTaskMasterMap(storeCode, departmentCode),
      fetch(`/shift/api/calc/assignments/daily/${dateString}?storeCode=${encodeURIComponent(storeCode)}${departmentCode?`&departmentCode=${encodeURIComponent(departmentCode)}`:''}`).then(r=>r.json()),
      fetch(`/shift/api/calc/employees/${storeCode}?date=${encodeURIComponent(dateString)}${departmentCode?`&departmentCode=${encodeURIComponent(departmentCode)}`:''}`).then(r=>r.json()),
      // 月次の勤務時間（シフト）を取得し、当日分にフィルタして利用
      fetch(`/shift/api/calc/shifts/monthly/${dateString.substring(0,7)}?storeCode=${encodeURIComponent(storeCode)}${departmentCode?`&departmentCode=${encodeURIComponent(departmentCode)}`:''}`).then(r=>r.json())
    ]);
    
    data = shiftData;
    employees = employeeData;
    workTimeMonthly = workTimeMonthlyResp || [];

    shiftGrid.innerHTML = ''; // Clear previous content
    
    if (employees && employees.length > 0) {
      noDataMessage.style.display = 'none';
      tableContainer.style.display = 'block';
      $('dragDropHelp').style.display = 'block';
      
      // 作業モデルと人時過不足データも同時に取得・表示
      loadWorkModel(dateString, data);
      loadDepartmentWorkModel(dateString);
      loadStaffingBalance(dateString);
    } else {
      noDataMessage.style.display = 'block';
      tableContainer.style.display = 'none';
      $('dragDropHelp').style.display = 'none';
      $('workModelCard').style.display = 'none';
      $('departmentWorkCard').style.display = 'none';
      $('staffingBalanceCard').style.display = 'none';
      return;
    }
  } catch (error) {
    console.error('データ取得エラー:', error);
    $('noDataMessage').style.display = 'block';
    $('tableContainer').style.display = 'none';
    $('dragDropHelp').style.display = 'none';
    $('workModelCard').style.display = 'none';
    $('departmentWorkCard').style.display = 'none';
    $('staffingBalanceCard').style.display = 'none';
    return;
  }

  // 時間ヘッダーを作成（解像度単位）
  // 解像度に応じて列数を動的化
  shiftGrid.style.gridTemplateColumns = `120px repeat(${SLOT_COUNT}, 50px)`;
  shiftGrid.style.minWidth = `${120 + (SLOT_COUNT * 50)}px`;
  const deptCodeForGrid = $('departmentCode').value || '';
  const IS_REGISTER_DEPT = (!deptCodeForGrid || deptCodeForGrid === '520');
  createTimeHeaderRow(shiftGrid, '従業員');

  // 従業員ごとの行を作成（シフト割り当て行 + 勤務時間行）
  employees.forEach((employee, employeeIndex) => {
    const shiftRowIndex = 2 + (employeeIndex * 2);
    const workRowIndex = shiftRowIndex + 1;
    // シフト割り当て行のヘッダー
    const employeeRowHeader = document.createElement('div');
    employeeRowHeader.className = 'grid-row-header';
    employeeRowHeader.innerHTML = `
      <div class="employee-name">${employee.employeeName}</div>
      <div class="employee-code">${employee.employeeCode}</div>
    `;
    setGridPosition(employeeRowHeader, shiftRowIndex, 1);
    
    shiftGrid.appendChild(employeeRowHeader);

    // シフト割り当てセル
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += RES_MIN) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell employee-shift-cell drop-zone';
        cell.dataset.employee = employee.employeeCode;
        cell.dataset.employeeName = employee.employeeName;
        cell.dataset.time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        cell.dataset.originalRegister = '';
        setGridPosition(cell, shiftRowIndex, gridColumnIndex(h, m));
        
        cell.addEventListener('dragover', handleDragOver);
        cell.addEventListener('drop', handleDrop);
        cell.addEventListener('dragleave', handleDragLeave);
        cell.addEventListener('contextmenu', handleRightClick);
        
        shiftGrid.appendChild(cell);
      }
    }
    
    // 勤務時間表示行のヘッダー
    const workHoursHeader = document.createElement('div');
    workHoursHeader.className = 'grid-row-header';
    workHoursHeader.style.fontSize = '0.7rem';
    workHoursHeader.textContent = '勤務時間';
    setGridPosition(workHoursHeader, workRowIndex, 1);
    
    shiftGrid.appendChild(workHoursHeader);
    
    // 勤務時間表示セル
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += RES_MIN) {
        const workHoursCell = document.createElement('div');
        workHoursCell.className = 'grid-cell work-hours-cell';
        workHoursCell.dataset.employee = employee.employeeCode;
        workHoursCell.dataset.time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        setGridPosition(workHoursCell, workRowIndex, gridColumnIndex(h, m));
        
        shiftGrid.appendChild(workHoursCell);
      }
    }
  });

  // 勤務時間（workTimeMonthly）で勤務行に薄色を塗る（レジ割当がなくても勤務中なら表示）
  if (workTimeMonthly && workTimeMonthly.length > 0) {
    const dayOnly = dateString; // 'YYYY-MM-DD'
    const workShiftsOfDay = workTimeMonthly.filter(s => {
      const d = new Date(s.startAt);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}` === dayOnly;
    });

    // グローバルに保持して、集計表示でも使う
    window._workShiftsOfDay = workShiftsOfDay;

    workShiftsOfDay.forEach(shift => {
      const start = new Date(shift.startAt);
      const end = new Date(shift.endAt);
      let cur = new Date(start);
      while (cur < end) {
        const hour = cur.getHours();
        const minute = cur.getMinutes();
        const targetTime = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        const cell = document.querySelector(`.work-hours-cell[data-employee="${shift.employeeCode}"][data-time="${targetTime}"]`);
        if (cell) cell.classList.add('working');
        cur.setMinutes(cur.getMinutes() + RES_MIN);
      }
    });
  } else {
    window._workShiftsOfDay = [];
  }

  // シフト割り当てデータでセルを塗りつぶし
  if (data && data.length > 0) {
    data.forEach(assignment => {
      const start = new Date(assignment.startAt);
      const end = new Date(assignment.endAt);
      const colorClass = getEmployeeColorClass(assignment.employeeName);

      // 解像度単位でセルを塗りつぶし
      let currentTime = new Date(start);
      while (currentTime < end) {
        const hour = currentTime.getHours();
        const minute = currentTime.getMinutes();
        const targetTime = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;

        const cell = shiftGrid.querySelector(`.employee-shift-cell[data-employee="${assignment.employeeCode}"][data-time="${targetTime}"]`);
        if (cell) {
          const workKind = assignment.workKind || 'REGISTER_OP';
          if (workKind === 'DEPARTMENT_TASK') {
            // 部門タスク割当（レジ番号無し）
            const taskLabel = getTaskName(assignment.taskCode, assignment.departmentCode);
            cell.textContent = '';
            cell.dataset.workKind = workKind;
            const taskCode = assignment.taskCode || '';
            const deptCode = assignment.departmentCode || selectedDepartmentCode();
            const taskValue = encodeTaskValue(deptCode, taskCode);
            cell.dataset.taskCode = taskCode;
            cell.dataset.departmentCode = deptCode;
            cell.dataset.taskLabel = taskLabel;
            cell.dataset.registerLabel = taskCode === 'BREAK' ? '休' : '';
            cell.dataset.originalRegister = taskValue;
            cell.dataset.currentRegister = taskValue;
            if (taskCode === 'BREAK') {
              cell.classList.add('break-assigned');
              cell.dataset.workKind = 'BREAK';
            } else {
              cell.classList.add('task-assigned');
            }
            cell.draggable = true;
            cell.removeEventListener('dragstart', handleAssignmentDragStart);
            cell.removeEventListener('dragend', handleAssignmentDragEnd);
            cell.addEventListener('dragstart', handleAssignmentDragStart);
            cell.addEventListener('dragend', handleAssignmentDragEnd);
          } else {
            cell.classList.add('assigned');
            const registerValue = assignment.registerNo;
            if (registerValue === 'break' || assignment.registerNo === 0) {
            // 休憩の場合
            cell.classList.add('break-assigned');
            cell.textContent = '';
            cell.dataset.workKind = 'BREAK';
            cell.dataset.registerLabel = '休';
            cell.dataset.originalRegister = 'break';
            cell.dataset.currentRegister = 'break';
            } else {
            // レジ割り当ての場合
            cell.classList.add(colorClass);
            cell.textContent = '';
            cell.dataset.workKind = workKind;
            cell.dataset.registerLabel = `R${assignment.registerNo}`;
            cell.dataset.originalRegister = assignment.registerNo;
            cell.dataset.currentRegister = assignment.registerNo;
            }
            cell.dataset.taskCode = '';
            cell.dataset.departmentCode = '';
            cell.dataset.taskLabel = '';
            
            cell.draggable = true;
            cell.removeEventListener('dragstart', handleAssignmentDragStart);
            cell.removeEventListener('dragend', handleAssignmentDragEnd);
            cell.addEventListener('dragstart', handleAssignmentDragStart);
            cell.addEventListener('dragend', handleAssignmentDragEnd);
          }
          
          // 従業員名を正しく設定（APIからの名前またはセルの従業員名を使用）
          const employeeName = assignment.employeeName || cell.dataset.employeeName;
          cell.dataset.assignedEmployeeName = employeeName;
        }
        currentTime.setMinutes(currentTime.getMinutes() + RES_MIN);
      }
    });
  }
  
  // スクロール同期をセットアップ
  setupScrollSync();
  
  // 勤務時間を計算・表示（勤務行の背景・合計時間ラベルなど）
  updateWorkHours();
  renderMergedAssignments();

  // レジ以外の場合は保存・キャンセルを隠して読み取り専用表示
  (function toggleEditButtons() {
    const departmentCode = $('departmentCode').value || '';
    const isRegisterDept = (!departmentCode || departmentCode === '520');
    const saveBtn = $('saveChangesBtn');
    const cancelBtn = $('cancelChangesBtn');
    const help = $('dragDropHelp');
    if (saveBtn) saveBtn.style.display = isRegisterDept ? 'inline-block' : 'none';
    if (cancelBtn) cancelBtn.style.display = isRegisterDept ? 'inline-block' : 'none';
    if (help) help.style.display = isRegisterDept ? 'block' : 'none';
  })();
}

async function loadStaffingBalance(dateString) {
  try {
    const storeCode = $('storeCode').value;
    const departmentCode = $('departmentCode').value || '';
    const staffingData = await fetch(`/shift/api/calc/staffing-balance/${dateString}?storeCode=${encodeURIComponent(storeCode)}${departmentCode?`&departmentCode=${encodeURIComponent(departmentCode)}`:''}`).then(r => r.json());
    const staffingGrid = $('staffingBalanceGrid');
    const staffingCard = $('staffingBalanceCard');
    
    staffingGrid.innerHTML = ''; // Clear previous content
    console.log('Staffing balance data:', staffingData); // デバッグ用
    
    if (staffingData && staffingData.length > 0) {
      staffingCard.style.display = 'block';
      
      // ヘッダー行を作成（必要・配置・差分の3行）
      const headers = ['必要人数', '配置人数', '過不足'];
      
      headers.forEach(headerText => {
        // 行ヘッダー
        const rowHeader = document.createElement('div');
        rowHeader.className = 'grid-row-header';
        rowHeader.textContent = headerText;
        staffingGrid.appendChild(rowHeader);
        
        // 時間スロット（解像度単位）
        for (let h = 0; h < 24; h++) {
          for (let m = 0; m < 60; m += RES_MIN) {
            const targetTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:00`;
            
            // 該当する時間帯のデータを検索
            const balanceData = staffingData.find(data => {
              if (!data.slotTime) return false;
              const timeStr = typeof data.slotTime === 'string' ? data.slotTime : 
                             (data.slotTime.hour !== undefined ? 
                              `${String(data.slotTime.hour).padStart(2, '0')}:${String(data.slotTime.minute).padStart(2, '0')}:00` : 
                              data.slotTime.toString());
              return timeStr === targetTime;
            });
            
            const cell = document.createElement('div');
            cell.className = 'grid-cell staffing-balance-cell';
            
            if (balanceData) {
              const required = balanceData.requiredStaff || 0;
              const assigned = balanceData.assignedStaff || 0;
              const balance = assigned - required;
              
              if (headerText === '必要人数') {
                cell.textContent = required;
                if (required > 0) {
                  cell.style.background = '#4ecdc4';
                  cell.style.color = 'white';
                }
              } else if (headerText === '配置人数') {
                cell.textContent = assigned;
                if (assigned > 0) {
                  cell.style.background = '#45b7d1';
                  cell.style.color = 'white';
                }
              } else if (headerText === '過不足') {
                if (balance < 0) {
                  cell.classList.add('shortage');
                  cell.innerHTML = `<div class="balance-value">${balance}</div><div class="balance-detail">不足</div>`;
                } else if (balance > 0) {
                  cell.classList.add('excess');
                  cell.innerHTML = `<div class="balance-value">+${balance}</div><div class="balance-detail">超過</div>`;
                } else if (required > 0) {
                  cell.classList.add('balanced');
                  cell.innerHTML = `<div class="balance-value">0</div><div class="balance-detail">適正</div>`;
                } else {
                  cell.textContent = '-';
                }
              }
            } else {
              cell.textContent = '-';
            }
            
            staffingGrid.appendChild(cell);
          }
        }
      });
      
      // 人時過不足用のCSSグリッドを設定（解像度に応じて）
      const sbCols = Math.floor(1440 / RES_MIN);
      staffingGrid.style.gridTemplateColumns = `120px repeat(${sbCols}, 50px)`;
      staffingGrid.style.gridTemplateRows = 'repeat(3, 35px)';
      staffingGrid.classList.add('shift-grid-container');
    } else {
      staffingCard.style.display = 'none';
    }
  } catch (error) {
    console.error('人時過不足データ取得エラー:', error);
    $('staffingBalanceCard').style.display = 'none';
  }
}

async function loadWorkModel(dateString, shiftData) {
  try {
    const storeCode = $('storeCode').value;
    const departmentCode = $('departmentCode').value || '';
    if (departmentCode && departmentCode !== '520') {
      $('workModelCard').style.display = 'none';
      return;
    }
    let workModelData = [];
    workModelData = await fetch(`/shift/api/calc/work-model-slot/${dateString}?storeCode=${encodeURIComponent(storeCode)}`).then(r => r.json());
    const workModelGrid = $('workModelGrid');
    const workModelCard = $('workModelCard');
    
    workModelGrid.innerHTML = ''; // Clear previous content
    console.log('Work model data:', workModelData); // デバッグ用
    console.log('Shift data for work model:', shiftData); // デバッグ用
    
    if (workModelData && workModelData.length > 0) {
      workModelCard.style.display = 'block';
      
      // 時間ヘッダーを作成（シフト表示と同じ解像度）
      createTimeHeaderRow(workModelGrid, '時間');

      // 表示対象のレジ番号を抽出
      let registerNos = Array.from(new Set(
        workModelData
          .map(d => d.registerNo)
          .filter(n => n !== null && n !== undefined)
      )).sort((a, b) => a - b);
      if (registerNos.length === 0) {
        const maxDemand = Math.max(...workModelData.map(d => d.requiredUnits || 0), 1);
        registerNos = Array.from({length: maxDemand}, (_, i) => i + 1);
      }
      
      // 各時間帯での需要データを事前に処理
      const demandByTimeRegister = new Map();
      for (let h = 0; h < 24; h++) {
        for (let m = 0; m < 60; m += RES_MIN) {
          const targetTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:00`;
          registerNos.forEach(regNo => {
            const quarterData = workModelData.find(d => {
              if (!d.slotTime) return false;
              if (d.registerNo !== regNo) return false;
              const timeStr = typeof d.slotTime === 'string' ? d.slotTime : 
                             (d.slotTime.hour !== undefined ? 
                              `${String(d.slotTime.hour).padStart(2, '0')}:${String(d.slotTime.minute).padStart(2, '0')}:00` : 
                              d.slotTime.toString());
              return timeStr === targetTime;
            });
            const demandCount = quarterData ? (quarterData.requiredUnits || 0) : 0;
            demandByTimeRegister.set(`${regNo}_${h}_${m}`, demandCount);
          });
        }
      }
      
      // シフトデータから時間・レジごとの従業員マッピングを作成
      const employeeByTimeRegister = new Map();
      if (shiftData && shiftData.length > 0) {
        shiftData.forEach(assignment => {
          const start = new Date(assignment.startAt);
          const end = new Date(assignment.endAt);
          const employeeName = assignment.employeeName || assignment.employeeCode;
          const registerNo = assignment.registerNo;
          
          // 解像度単位でマッピングを作成
          let currentTime = new Date(start);
          while (currentTime < end) {
            const hour = currentTime.getHours();
            const minute = currentTime.getMinutes();
            const key = `${hour}_${minute}_${registerNo}`;
            employeeByTimeRegister.set(key, employeeName);
            currentTime.setMinutes(currentTime.getMinutes() + RES_MIN);
          }
        });
      }

      // レジ番号の行を作成（需要で指定されたレジ）
      for (const registerNo of registerNos) {
        const registerRowHeader = document.createElement('div');
        registerRowHeader.className = 'grid-row-header';
        registerRowHeader.textContent = `レジ ${registerNo}`;
        workModelGrid.appendChild(registerRowHeader);

        for (let h = 0; h < 24; h++) {
          for (let m = 0; m < 60; m += RES_MIN) {
            const demandCount = demandByTimeRegister.get(`${registerNo}_${h}_${m}`) || 0;
            
            // この時間帯にこのレジ番号が必要な場合のみセルを作成
            if (demandCount > 0) {
              const cell = document.createElement('div');
              cell.className = 'grid-cell work-model-cell register-needed';
              
              // 割り当てられた従業員名を取得
              const employeeKey = `${h}_${m}_${registerNo}`;
              const employeeName = employeeByTimeRegister.get(employeeKey);
              
              if (employeeName) {
                // 従業員名の頭2文字を表示
                const shortName = employeeName.length >= 2 ? employeeName.substring(0, 2) : employeeName;
                cell.textContent = shortName;
                cell.classList.add('has-employee');
              }
              
              workModelGrid.appendChild(cell);
            } else {
              // 不要な場合は空のdivを作成（グリッドレイアウト維持のため）
              const emptyCell = document.createElement('div');
              emptyCell.className = 'grid-cell work-model-cell-empty';
              workModelGrid.appendChild(emptyCell);
            }
          }
        }
      }
      
      // 作業モデル用のCSSグリッドを設定（解像度に合わせて動的化）
      workModelGrid.style.gridTemplateColumns = `120px repeat(${SLOT_COUNT}, 50px)`;
      workModelGrid.style.minWidth = `${120 + (SLOT_COUNT * 50)}px`;
      workModelGrid.classList.add('shift-grid-container');
    } else {
      workModelCard.style.display = 'none';
    }
  } catch (error) {
    console.error('作業モデルデータ取得エラー:', error);
    $('workModelCard').style.display = 'none';
  }
}

async function loadDepartmentWorkModel(dateString) {
  try {
    const storeCode = $('storeCode').value;
    const departmentCode = $('departmentCode').value || '';
    const departmentWorkCard = $('departmentWorkCard');
    const departmentWorkGrid = $('departmentWorkGrid');
    const data = await fetch(`/shift/api/calc/department-task-slot/${dateString}?storeCode=${encodeURIComponent(storeCode)}${departmentCode ? `&departmentCode=${encodeURIComponent(departmentCode)}` : ''}`).then(r=>r.json());
    departmentWorkGrid.innerHTML = '';
    if (!data || data.length === 0) {
      departmentWorkCard.style.display = 'none';
      return;
    }
    departmentWorkCard.style.display = 'block';

    createTimeHeaderRow(departmentWorkGrid, '作業');

    const rows = Array.from(new Set(data.map(d => `${d.departmentCode || 'DEPT'}::${d.taskCode || 'TASK'}`))).sort();
    const demandByTaskTime = new Map();

    const toTimeKey = (slotTime) => {
      if (!slotTime) return null;
      if (typeof slotTime === 'string') return slotTime.substring(0, 5);
      if (slotTime.hour !== undefined) {
        const hh = String(slotTime.hour).padStart(2, '0');
        const mm = String(slotTime.minute || 0).padStart(2, '0');
        return `${hh}:${mm}`;
      }
      return slotTime.toString().substring(0, 5);
    };

    data.forEach(d => {
      const t = toTimeKey(d.slotTime);
      if (!t) return;
      const key = `${d.departmentCode || 'DEPT'}::${d.taskCode || 'TASK'}_${t}`;
      demandByTaskTime.set(key, d.requiredUnits || 0);
    });

    const timeSlots = buildTimeSlots();

    rows.forEach((rowKey, rowIndex) => {
      const [deptCode, taskCode] = rowKey.split('::');
      const taskRowHeader = document.createElement('div');
      taskRowHeader.className = 'grid-row-header';
      const taskLabel = taskCode === 'TASK' ? '作業' : getTaskName(taskCode, deptCode);
      const headerLabel = departmentCode ? taskLabel : `${deptCode} / ${taskLabel}`;
      taskRowHeader.textContent = headerLabel;
      taskRowHeader.style.gridRow = `${rowIndex + 2}`;
      taskRowHeader.style.gridColumn = '1';
      departmentWorkGrid.appendChild(taskRowHeader);

      timeSlots.forEach((_, idx) => {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'grid-cell department-work-cell-empty';
        emptyCell.style.gridRow = `${rowIndex + 2}`;
        emptyCell.style.gridColumn = `${idx + 2}`;
        departmentWorkGrid.appendChild(emptyCell);
      });

      let startIdx = null;
      let currentDemand = 0;
      timeSlots.forEach((timeKey, idx) => {
        const demand = demandByTaskTime.get(`${rowKey}_${timeKey}`) || 0;
        if (demand > 0) {
          if (startIdx === null || demand !== currentDemand) {
            if (startIdx !== null) {
              const block = document.createElement('div');
              block.className = 'dept-plan-block';
              block.style.background = getTaskDisplayColor(taskCode);
              block.style.gridRow = `${rowIndex + 2}`;
              block.style.gridColumn = `${startIdx + 2} / ${idx + 2}`;
              block.textContent = `${taskLabel} x${currentDemand}`;
              departmentWorkGrid.appendChild(block);
            }
            startIdx = idx;
            currentDemand = demand;
          }
        } else if (startIdx !== null) {
          const block = document.createElement('div');
          block.className = 'dept-plan-block';
          block.style.background = getTaskDisplayColor(taskCode);
          block.style.gridRow = `${rowIndex + 2}`;
          block.style.gridColumn = `${startIdx + 2} / ${idx + 2}`;
          block.textContent = `${taskLabel} x${currentDemand}`;
          departmentWorkGrid.appendChild(block);
          startIdx = null;
          currentDemand = 0;
        }
      });

      if (startIdx !== null) {
        const block = document.createElement('div');
        block.className = 'dept-plan-block';
        block.style.background = getTaskDisplayColor(taskCode);
        block.style.gridRow = `${rowIndex + 2}`;
        block.style.gridColumn = `${startIdx + 2} / ${timeSlots.length + 2}`;
        block.textContent = `${taskLabel} x${currentDemand}`;
        departmentWorkGrid.appendChild(block);
      }
    });

    departmentWorkGrid.style.gridTemplateColumns = `120px repeat(${SLOT_COUNT}, 50px)`;
    departmentWorkGrid.style.minWidth = `${120 + (SLOT_COUNT * 50)}px`;
    departmentWorkGrid.classList.add('shift-grid-container');
  } catch (error) {
    console.error('部門別作業量データ取得エラー:', error);
    $('departmentWorkCard').style.display = 'none';
  }
}

// 現在の割り当て状況で作業モデルを更新
function updateWorkModel() {
  // 現在のシフトデータを収集
  const currentShiftData = [];
  const shiftCells = document.querySelectorAll('.grid-cell.assigned[data-current-register]');
  
  shiftCells.forEach(cell => {
    const employeeCode = cell.dataset.employee;
    const employeeName = cell.dataset.assignedEmployeeName || cell.dataset.employeeName;
    const time = cell.dataset.time;
    const registerNo = parseInt(cell.dataset.currentRegister);
    
    if (registerNo && time) {
      const [hour, minute] = time.split(':').map(Number);
      const startAt = new Date();
      startAt.setHours(hour, minute, 0, 0);
      const endAt = new Date(startAt);
      endAt.setMinutes(endAt.getMinutes() + RES_MIN);
      
      currentShiftData.push({
        employeeCode,
        employeeName,
        registerNo,
        startAt: startAt.toISOString(),
        endAt: endAt.toISOString()
      });
    }
  });
  
  // 作業モデルのセルを更新
  const workModelCells = document.querySelectorAll('.work-model-cell.register-needed');
  
  // 従業員マッピングを再作成
  const employeeByTimeRegister = new Map();
  currentShiftData.forEach(assignment => {
    const start = new Date(assignment.startAt);
    const hour = start.getHours();
    const minute = start.getMinutes();
    const key = `${hour}_${minute}_${assignment.registerNo}`;
    employeeByTimeRegister.set(key, assignment.employeeName);
  });
  
  // 各セルを更新
  let cellIndex = 0;
  const workModelGrid = $('workModelGrid');
  if (!workModelGrid) return;
  
  // 作業モデルのグリッド構造を仮定してセルを更新
  const workModelData = document.querySelectorAll('.work-model-cell.register-needed');
  
  // 現在表示されている作業モデルを基に更新
  for (let registerNo = 1; registerNo <= 10; registerNo++) { // 最大レジ数を仮定
    for (let h = 0; h < 24; h++) {
      for (let m = 0; m < 60; m += RES_MIN) {
        const cell = workModelData[cellIndex];
        if (cell) {
          const employeeKey = `${h}_${m}_${registerNo}`;
          const employeeName = employeeByTimeRegister.get(employeeKey);
          
          cell.classList.remove('has-employee');
          cell.textContent = '';
          
          if (employeeName) {
            const shortName = employeeName.length >= 2 ? employeeName.substring(0, 2) : employeeName;
            cell.textContent = shortName;
            cell.classList.add('has-employee');
          }
          
          cellIndex++;
        }
      }
    }
  }
}

// 現在の割り当て状況で人時過不足を更新
function updateStaffingBalance() {
  const staffingGrid = $('staffingBalanceGrid');
  if (!staffingGrid) return;
  
  // 現在のシフトデータを収集
  const currentShiftData = [];
  const shiftCells = document.querySelectorAll('.grid-cell.assigned[data-current-register]');
  
  shiftCells.forEach(cell => {
    const employeeCode = cell.dataset.employee;
    const time = cell.dataset.time;
    const registerNo = parseInt(cell.dataset.currentRegister);
    
    if (registerNo && time) {
      const [hour, minute] = time.split(':').map(Number);
      currentShiftData.push({
        employeeCode,
        time: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`
      });
    }
  });
  
  // 時間帯別の配置人数をカウント
  const assignedCountsByTime = new Map();
  currentShiftData.forEach(assignment => {
    const timeKey = assignment.time;
    assignedCountsByTime.set(timeKey, (assignedCountsByTime.get(timeKey) || 0) + 1);
  });
  
  // 過不足行（3行目）のセルを更新
  const balanceCells = staffingGrid.querySelectorAll('.grid-cell');
  
  // 3行目の過不足セルのみ更新（0から始まるインデックスで2行目）
  const rowSize = 1 + SLOT_COUNT; // ヘッダー1 + 時間スロット
  const balanceRowStartIndex = rowSize * 2; // 3行目の開始インデックス
  
  for (let i = 0; i < SLOT_COUNT; i++) { // 時間スロット
    const cellIndex = balanceRowStartIndex + 1 + i; // +1はヘッダー分
    const cell = balanceCells[cellIndex];
    
    if (cell) {
      const h = Math.floor(i / PER_HOUR);
      const m = (i % PER_HOUR) * RES_MIN;
      const targetTime = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:00`;
      
      // 元の必要人数を取得（データから）
      const requiredCell = balanceCells[1 + i]; // 1行目の対応するセル
      const required = requiredCell ? parseInt(requiredCell.textContent) || 0 : 0;
      
      // 現在の配置人数を取得
      const assigned = assignedCountsByTime.get(targetTime) || 0;
      
      // 配置人数行（2行目）を更新
      const assignedCell = balanceCells[rowSize + 1 + i];
      if (assignedCell) {
        assignedCell.textContent = assigned;
        if (assigned > 0) {
          assignedCell.style.background = '#45b7d1';
          assignedCell.style.color = 'white';
        } else {
          assignedCell.style.background = '#f8f9fa';
          assignedCell.style.color = '#6c757d';
        }
      }
      
      // 過不足を計算して更新
      const balance = assigned - required;
      
      // セルのクラスをリセット
      cell.classList.remove('shortage', 'excess', 'balanced');
      
      if (balance < 0) {
        cell.classList.add('shortage');
        cell.innerHTML = `<div class="balance-value">${balance}</div><div class="balance-detail">不足</div>`;
      } else if (balance > 0) {
        cell.classList.add('excess');
        cell.innerHTML = `<div class="balance-value">+${balance}</div><div class="balance-detail">超過</div>`;
      } else if (required > 0) {
        cell.classList.add('balanced');
        cell.innerHTML = `<div class="balance-value">0</div><div class="balance-detail">適正</div>`;
      } else {
        cell.textContent = '-';
      }
    }
  }
}

// 勤務時間を計算・表示する関数
function updateWorkHours() {
  const employees = document.querySelectorAll('.employee-shift-cell');
  if (employees.length === 0) return;
  
  // 従業員コードごとにグループ化
  const employeeCodes = new Set();
  employees.forEach(cell => { if (cell.dataset.employee) employeeCodes.add(cell.dataset.employee); });
  
  employeeCodes.forEach(employeeCode => {
    // この従業員の割り当てセルを取得
    const assignmentCells = document.querySelectorAll(`.employee-shift-cell[data-employee="${employeeCode}"]`);
    const workHoursCells = document.querySelectorAll(`.work-hours-cell[data-employee="${employeeCode}"]`);
    
    // 勤務時間スロットを勤務シフト（_workShiftsOfDay）から構成
    const timeSlots = new Map(); // time -> { working: boolean }
    const workByEmp = (window._workShiftsOfDay || []).filter(s => s.employeeCode === employeeCode);
    workByEmp.forEach(shift => {
      let cur = new Date(shift.startAt);
      const end = new Date(shift.endAt);
      while (cur < end) {
        const hh = String(cur.getHours()).padStart(2,'0');
        const mm = String(cur.getMinutes()).padStart(2,'0');
        timeSlots.set(`${hh}:${mm}`, { working: true });
        cur.setMinutes(cur.getMinutes() + RES_MIN);
      }
    });
    
    // 勤務時間セルを更新
    workHoursCells.forEach(cell => {
      const time = cell.dataset.time;
      const status = timeSlots.get(time);
      
      // セルをクリア
      cell.textContent = '';
      if (status && status.working) {
        cell.classList.add('working');
      } else {
        cell.classList.remove('working');
      }
    });
    
    // 連続勤務時間の計算（休憩を除く）
    calculateContinuousWorkPeriods(employeeCode, timeSlots, workHoursCells);
  });
}

// 連続勤務時間を計算して表示
function calculateContinuousWorkPeriods(employeeCode, timeSlots, workHoursCells) {
  const times = Array.from(timeSlots.keys()).sort();
  let workPeriods = [];
  let currentPeriod = null;
  
  times.forEach(time => {
    const status = timeSlots.get(time);
    
    if (status && status.working) {
      // 勤務時間
      if (!currentPeriod) {
        currentPeriod = { start: time, end: time, duration: RES_MIN };
      } else {
        currentPeriod.end = time;
        currentPeriod.duration += RES_MIN;
      }
    } else {
      // 未割り当てまたは休憩
      if (currentPeriod) {
        workPeriods.push(currentPeriod);
        currentPeriod = null;
      }
    }
  });
  
  // 最後の期間を追加
  if (currentPeriod) {
    workPeriods.push(currentPeriod);
  }
  
  // 勤務時間の表示を更新（開始時間のみ表示、期間が長い場合は時間数も表示）
  workHoursCells.forEach(cell => {
    const time = cell.dataset.time;
    const status = timeSlots.get(time);
    
    if (status && status.assigned && !status.break) {
      // この時間が勤務期間の開始かどうかチェック
      const period = workPeriods.find(p => p.start === time);
      if (period) {
        const hours = Math.floor(period.duration / 60);
        const minutes = period.duration % 60;
        
        if (hours > 0) {
          cell.textContent = `${hours}h${minutes > 0 ? minutes + 'm' : ''}`;
        } else {
          cell.textContent = `${minutes}m`;
        }
      }
    }
  });
}
</script>
</div>
</body>
</html>
