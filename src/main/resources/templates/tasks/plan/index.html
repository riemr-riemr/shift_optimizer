<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~{layout}">
<head>
  <meta charset="UTF-8">
  <title>作業計画</title>
</head>
<body>
<main layout:fragment="content">
  <div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
      <span>作業計画</span>
    </div>
    <div class="card-body">
      <form class="row g-2 mb-3" id="planForm">
        <div class="col-auto"><input class="form-control form-control-sm" name="store" placeholder="店舗コード" th:value="${storeCode}"></div>
        <div class="col-auto">
          <select class="form-select form-select-sm" name="mode" id="modeSelect">
            <option th:selected="${mode}=='weekly'" value="weekly">曜日</option>
            <option th:selected="${mode}=='special'" value="special">特異日</option>
          </select>
        </div>
        <div class="col-auto" style="min-width: 220px;">
          <select class="form-select form-select-sm" name="dept" id="deptSelect" required>
            <option value="" th:selected="${dept == null or dept == ''}">部門を選択</option>
            <option th:each="d : ${departments}"
                    th:value="${d.departmentCode}"
                    th:selected="${dept == d.departmentCode}"
                    th:text="${d.departmentCode} + ' - ' + ${d.departmentName}"></option>
          </select>
        </div>
        <!-- 特異日: 登録済み特異日を選択するプルダウン -->
        <div class="col-auto" th:if="${mode}=='special'">
          <select class="form-select form-select-sm" name="sd">
            <option value="" th:selected="${sd==null}">特異日を選択</option>
            <option th:each="dm : ${days}"
                    th:value="${#dates.format(dm.specialDate,'yyyy-MM-dd')}"
                    th:selected="${sd}==${dm.specialDate}"
                    th:text="${#dates.format(dm.specialDate,'MM/dd')} + ' ' + ${dm.label}">
            </option>
          </select>
        </div>
        <div class="col-auto" th:if="${mode}=='weekly'">
          <select class="form-select form-select-sm" name="day">
            <option th:value="1" th:selected="${day==1}">月</option>
            <option th:value="2" th:selected="${day==2}">火</option>
            <option th:value="3" th:selected="${day==3}">水</option>
            <option th:value="4" th:selected="${day==4}">木</option>
            <option th:value="5" th:selected="${day==5}">金</option>
            <option th:value="6" th:selected="${day==6}">土</option>
            <option th:value="7" th:selected="${day==7}">日</option>
          </select>
        </div>
        <!-- 特異日: タブ選択は下部に表示 -->
        <div class="col-auto"><button class="btn btn-sm btn-primary" type="submit">表示</button></div>
      </form>

      <!-- 追加UI: 曜日は表示のみ。特異日はダイアログで追加 -->
      <div class="mb-3">
        <button class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#specialAddModal">特異日追加</button>
      </div>

      <!-- 適用処理は月次シフト最適化時に実行されます -->


      <div th:if="${not #lists.isEmpty(list)}" class="table-responsive">
        <table class="table table-sm table-hover editable-table">
          <thead class="table-light">
            <tr th:if="${mode}=='weekly'">
              <th>曜日</th><th>部門</th><th>作業</th><th>タイプ</th><th>開始時間</th><th>終了時間</th><th>人数</th><th>期間(開始)</th><th>期間(終了)</th><th>アクション</th>
            </tr>
            <tr th:if="${mode}=='special'">
              <th>特異日</th><th>部門</th><th>作業</th><th>タイプ</th><th>開始時間</th><th>終了時間</th><th>人数</th><th>備考</th><th>アクション</th>
            </tr>
          </thead>
          <tbody>
            <tr th:each="p : ${list}" th:attr="data-plan-id=${p.planId}" class="editable-row">
              <td th:if="${mode}=='weekly'">
                <select class="form-select form-select-sm" name="dayOfWeek" th:attr="data-original=${p.dayOfWeek}">
                  <option th:value="1" th:selected="${p.dayOfWeek == 1}">月</option>
                  <option th:value="2" th:selected="${p.dayOfWeek == 2}">火</option>
                  <option th:value="3" th:selected="${p.dayOfWeek == 3}">水</option>
                  <option th:value="4" th:selected="${p.dayOfWeek == 4}">木</option>
                  <option th:value="5" th:selected="${p.dayOfWeek == 5}">金</option>
                  <option th:value="6" th:selected="${p.dayOfWeek == 6}">土</option>
                  <option th:value="7" th:selected="${p.dayOfWeek == 7}">日</option>
                </select>
              </td>
              <td th:if="${mode}=='special'">
                <input type="date" class="form-control form-control-sm" name="specialDate" 
                       th:value="${p.specialDate != null ? #dates.format(p.specialDate, 'yyyy-MM-dd') : ''}"
                       th:attr="data-original=${p.specialDate != null ? #dates.format(p.specialDate, 'yyyy-MM-dd') : ''}">
              </td>
              <td>
                <select class="form-select form-select-sm" name="departmentCode" th:attr="data-original=${p.departmentCode}">
                  <option value="">選択</option>
                  <option th:each="d : ${departments}" 
                          th:value="${d.departmentCode}"
                          th:selected="${p.departmentCode == d.departmentCode}"
                          th:text="${d.departmentCode} + ' - ' + ${d.departmentName}"></option>
                </select>
              </td>
              <td>
                <select class="form-select form-select-sm task-select" name="taskCode" th:attr="data-original=${p.taskCode}">
                  <option value="">選択</option>
                </select>
              </td>
              <td>
                <select class="form-select form-select-sm" name="scheduleType" th:attr="data-original=${p.scheduleType}">
                  <option value="FIXED" th:selected="${p.scheduleType == 'FIXED'}">固定</option>
                  <option value="FLEXIBLE" th:selected="${p.scheduleType == 'FLEXIBLE'}">可変</option>
                </select>
              </td>
              <td>
                <input type="time" class="form-control form-control-sm" name="fixedStartTime" step="900"
                       th:value="${p.fixedStartTime != null ? #dates.format(p.fixedStartTime, 'HH:mm') : ''}"
                       th:attr="data-original=${p.fixedStartTime != null ? #dates.format(p.fixedStartTime, 'HH:mm') : ''}">
              </td>
              <td>
                <input type="time" class="form-control form-control-sm" name="fixedEndTime" step="900"
                       th:value="${p.fixedEndTime != null ? #dates.format(p.fixedEndTime, 'HH:mm') : ''}"
                       th:attr="data-original=${p.fixedEndTime != null ? #dates.format(p.fixedEndTime, 'HH:mm') : ''}">
              </td>
              <td>
                <input type="number" class="form-control form-control-sm" name="requiredStaffCount" min="1"
                       th:value="${p.requiredStaffCount}" th:attr="data-original=${p.requiredStaffCount}">
              </td>
              <td th:if="${mode}=='weekly'">
                <input type="date" class="form-control form-control-sm" name="effectiveFrom"
                       th:value="${p.effectiveFrom != null ? #dates.format(p.effectiveFrom, 'yyyy-MM-dd') : ''}"
                       th:attr="data-original=${p.effectiveFrom != null ? #dates.format(p.effectiveFrom, 'yyyy-MM-dd') : ''}">
              </td>
              <td th:if="${mode}=='weekly'">
                <input type="date" class="form-control form-control-sm" name="effectiveTo"
                       th:value="${p.effectiveTo != null ? #dates.format(p.effectiveTo, 'yyyy-MM-dd') : ''}"
                       th:attr="data-original=${p.effectiveTo != null ? #dates.format(p.effectiveTo, 'yyyy-MM-dd') : ''}">
              </td>
              <td th:if="${mode}=='special'">
                <input type="text" class="form-control form-control-sm" name="note"
                       th:value="${p.note}" th:attr="data-original=${p.note}">
              </td>
              <td>
                <div class="btn-group" role="group">
                  <button type="button" class="btn btn-sm btn-outline-success save-btn" title="保存">
                    <i class="bi bi-check"></i>
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-secondary reset-btn" title="リセット">
                    <i class="bi bi-arrow-counterclockwise"></i>
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-danger delete-btn" title="削除">
                    <i class="bi bi-trash"></i>
                  </button>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <div th:if="${#lists.isEmpty(list)}" class="text-center text-muted py-4">
        <i class="bi bi-info-circle"></i> 表示するデータがありません
      </div>

      <!-- グリッドUI: 15分×15行の簡易エディタ -->
      <div class="mt-4" th:if="${storeCode} != null">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div class="fw-bold">グリッド編集（1セル=15分/1人）</div>
          <div class="d-flex align-items-center gap-2">
            <div class="small text-muted">横軸: 時間 / 縦軸: 15レーン</div>
          </div>
        </div>
        <div class="row g-2 align-items-end mb-2">
          <div class="col-auto d-flex align-items-end">
            <div>
              <label class="form-label form-label-sm mb-1">作業マスタ</label>
              <div class="small text-muted">左のツリーから選択</div>
              <input type="hidden" id="gridTask" value="">
              <div class="mt-1 small">選択中: <span id="selectedTaskLabel" class="fw-bold">未選択</span></div>
            </div>
          </div>
          <!-- 日付/曜日選択は上部の検索フォームの値を使用（ここでは表示しない） -->
        </div>

        <style>
          .time-grid-wrapper { overflow-x: auto; border: 1px solid #dee2e6; border-radius: 6px; background: #fff; }
          .time-grid { display: grid; grid-auto-rows: 28px; position: relative; }
          .time-grid .cell { border-right: 1px solid #f0f0f0; border-bottom: 1px solid #f7f7f7; cursor: pointer; }
          .time-grid .cell:hover { background: #f1f5ff; }
          /* Single object style for plans */
          .plan-block { position: absolute; border: 1px solid #333; box-shadow: 0 1px 2px rgba(0,0,0,0.2); border-radius: 3px; overflow: hidden; z-index: 4; cursor: pointer; }
          .plan-block .resize-handle { position: absolute; right: 2px; bottom: 2px; width: 10px; height: 10px; background: rgba(0,0,0,0.35); border-radius: 2px; cursor: se-resize; }
          .plan-block .task-label { font-size: 10px; color: #fff; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 2px 16px 2px 4px; text-shadow: 1px 1px 1px rgba(0,0,0,0.5); }
          /* Flexible window overlay */
          .plan-window { position: absolute; border: 1px dashed rgba(0,0,0,0.2); border-radius: 3px; z-index: 3; }
          .plan-window.task-cell-reg { background: rgba(255, 107, 107, 0.25); }
          .plan-window.task-cell-stock { background: rgba(78, 205, 196, 0.25); }
          .plan-window.task-cell-clean { background: rgba(69, 183, 209, 0.25); }
          .plan-window.task-cell-default { background: rgba(149, 165, 166, 0.25); }
          .time-grid .cell.selecting { background: #ffe599; }
          .time-grid .cell.selected-range { background: #b6e0fe; }
          .task-cell-reg { background: #ff6b6b; }
          .task-cell-stock { background: #4ecdc4; }
          .task-cell-clean { background: #45b7d1; }
          .task-cell-default { background: #95a5a6; }
          .time-grid .row-label { position: sticky; left: 0; background: #f8f9fa; border-right: 1px solid #dee2e6; z-index: 2; display:flex; align-items:center; justify-content:center; font-size: 12px; color:#6c757d; }
          .time-grid .header { position: sticky; top: 0; background: #f8f9fa; z-index: 3; border-bottom: 1px solid #dee2e6; font-size: 12px; color:#6c757d; display:flex; align-items:center; justify-content:center; }
          .time-grid .header-hour { border-right: 1px solid #eee; }
          /* Task tree (always visible) */
          .grid-editor { display: grid; grid-template-columns: 280px 1fr; gap: 12px; align-items: start; }
          .task-tree { width: 100%; max-height: 620px; overflow:auto; }
          .grid-pane { min-width: 0; }
          .task-tree .list-group-item.category { font-weight: 600; cursor: pointer; display:flex; align-items:center; gap:6px; }
          .task-tree .list-group-item.task { padding-left: 28px; cursor: pointer; }
          .task-tree .list-group-item.task.selected { background: #0d6efd; color: #fff; }
          .chev { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 6px solid #6c757d; display:inline-block; transform: rotate(-90deg); transition: transform .15s; }
          .chev.open { transform: rotate(0deg); }
        </style>
        <div class="grid-editor mt-2">
          <div class="task-tree card shadow-sm">
            <div class="list-group list-group-flush" id="taskTreeList"></div>
          </div>
          <div class="grid-pane flex-grow-1">
            <div class="time-grid-wrapper">
              <div id="timeGrid" class="time-grid"></div>
            </div>
            <div id="gridMessage" class="alert alert-danger py-1 px-2 small d-none mt-2" role="alert"></div>
            <div class="d-flex justify-content-end mt-2">
              <button id="gridSaveBtn" type="button" class="btn btn-sm btn-success">保存</button>
            </div>
            <div class="form-text mt-1">ドラッグで範囲選択して登録します（1セル=15分）。作業・部門を選択のうえ操作してください。</div>
          </div>
        </div>
      </div>

      <!-- 右クリックメニュー -->
      <div id="planCtxMenu" class="card shadow" style="position:absolute; display:none; z-index:2000; min-width: 160px;">
        <div class="list-group list-group-flush">
          <button type="button" class="list-group-item list-group-item-action" id="ctxEditBtn">編集</button>
          <button type="button" class="list-group-item list-group-item-action text-danger" id="ctxDeleteBtn">削除</button>
        </div>
      </div>

      <!-- 編集モーダル -->
      <div class="modal fade" id="planEditModal" tabindex="-1">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">計画の編集</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <div class="row g-2">
                <div class="col-6">
                  <label class="form-label">スケジュールタイプ</label>
                  <select class="form-select" id="editScheduleType">
                    <option value="FIXED">固定</option>
                    <option value="FLEXIBLE">可変</option>
                  </select>
                </div>
                <div class="col-6">
                  <label class="form-label">人数</label>
                  <input type="number" min="1" class="form-control" id="editStaff" value="1">
                </div>

                <div class="col-6 fixed-group">
                  <label class="form-label">開始</label>
                  <input type="time" class="form-control" id="editStart" step="900">
                </div>
                <div class="col-6 fixed-group">
                  <label class="form-label">終了</label>
                  <input type="time" class="form-control" id="editEnd" step="900">
                </div>

                <div class="col-4 flexible-group" style="display:none;">
                  <label class="form-label">窓開始</label>
                  <input type="time" class="form-control" id="editWinStart" step="900">
                </div>
                <div class="col-4 flexible-group" style="display:none;">
                  <label class="form-label">窓終了</label>
                  <input type="time" class="form-control" id="editWinEnd" step="900">
                </div>
                <div class="col-4 flexible-group" style="display:none;">
                  <label class="form-label">所要(分)</label>
                  <input type="number" min="0" step="15" class="form-control" id="editDuration">
                </div>

                <div class="col-6 d-flex align-items-end">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="editActive" checked>
                    <label class="form-check-label" for="editActive">有効</label>
                  </div>
                </div>
                <div class="col-12">
                  <label class="form-label">備考</label>
                  <input type="text" class="form-control" id="editNote">
                </div>
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-danger me-auto" id="editDeleteBtn">削除</button>
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
              <button type="button" class="btn btn-primary" id="editSaveBtn">保存</button>
            </div>
          </div>
        </div>
      </div>

      <!-- 特異日 作業追加モーダル -->
      <div class="modal fade" id="specialPlanAddModal" tabindex="-1" th:if="${mode}=='special' and ${sd} != null">
        <div class="modal-dialog modal-lg">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">作業を追加（特異日: <span th:text="${#dates.format(sd,'MM/dd')}"></span>）</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form th:action="@{/tasks/plan}" th:object="${form}" method="post">
              <input type="hidden" name="mode" value="special">
              <div class="modal-body">
            <div class="row g-2 mb-2">
              <div class="col-3"><input class="form-control form-control-sm" th:field="*{storeCode}" placeholder="店舗" th:value="${storeCode}" required></div>
              <div class="col-3"><input class="form-control form-control-sm" th:field="*{departmentCode}" placeholder="部門コード"></div>
              <div class="col-3"><input class="form-control form-control-sm" type="date" th:field="*{specialDate}" th:value="${#dates.format(sd,'yyyy-MM-dd')}" required></div>
              <div class="col-3">
                <select class="form-select form-select-sm task-select" th:field="*{taskCode}" required>
                  <option value="" disabled selected>作業マスタを選択</option>
                </select>
              </div>
            </div>
                <div class="row g-2 mb-2">
                  <div class="col-3"><select class="form-select form-select-sm" th:field="*{scheduleType}"><option value="FIXED">固定</option><option value="FLEXIBLE">可変</option></select></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{fixedStartTime}" placeholder="開始"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{fixedEndTime}" placeholder="終了"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="number" th:field="*{requiredStaffCount}" placeholder="人数"></div>
                </div>
                <div class="row g-2 mb-2">
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{windowStartTime}" placeholder="Win開始"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{windowEndTime}" placeholder="Win終了"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="number" step="15" th:field="*{requiredDurationMinutes}" placeholder="所要(分)"></div>
                  <div class="col-3"><input class="form-control form-control-sm" th:field="*{note}" placeholder="備考"></div>
                </div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
                <button type="submit" class="btn btn-primary">追加</button>
              </div>
            </form>
          </div>
        </div>
      </div>

      <!-- 作業追加ボタン（特異日選択時のみ） -->
      <div class="mt-2" th:if="${mode}=='special' and ${sd} != null">
        <button class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#specialPlanAddModal">作業追加</button>
      </div>

      <!-- 曜日 作業追加モーダル -->
      <div class="modal fade" id="weeklyPlanAddModal" tabindex="-1" th:if="${mode}=='weekly'">
        <div class="modal-dialog modal-lg">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">作業を追加（曜日: <span th:text="${day}"></span>）</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form th:action="@{/tasks/plan}" th:object="${form}" method="post">
              <input type="hidden" name="mode" value="weekly">
              <div class="modal-body">
            <div class="row g-2 mb-2">
              <div class="col-3"><input class="form-control form-control-sm" th:field="*{storeCode}" placeholder="店舗" th:value="${storeCode}" required></div>
              <div class="col-3"><input class="form-control form-control-sm" type="number" th:field="*{dayOfWeek}" th:value="${day}" min="1" max="7" required></div>
              <div class="col-3"><input class="form-control form-control-sm" th:field="*{departmentCode}" placeholder="部門コード"></div>
              <div class="col-3">
                <select class="form-select form-select-sm task-select" th:field="*{taskCode}" required>
                  <option value="" disabled selected>作業マスタを選択</option>
                </select>
              </div>
            </div>
                <div class="row g-2 mb-2">
                  <div class="col-3"><select class="form-select form-select-sm" th:field="*{scheduleType}"><option value="FIXED">固定</option><option value="FLEXIBLE">可変</option></select></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{fixedStartTime}" placeholder="開始"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{fixedEndTime}" placeholder="終了"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="number" th:field="*{requiredStaffCount}" placeholder="人数"></div>
                </div>
                <div class="row g-2 mb-2">
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{windowStartTime}" placeholder="Win開始"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="time" step="900" th:field="*{windowEndTime}" placeholder="Win終了"></div>
                  <div class="col-3"><input class="form-control form-control-sm" type="number" step="15" th:field="*{requiredDurationMinutes}" placeholder="所要(分)"></div>
                  <div class="col-3"><input class="form-control form-control-sm" th:field="*{note}" placeholder="備考"></div>
                </div>
                <div class="row g-2 mb-2">
                  <div class="col-4"><input class="form-control form-control-sm" type="date" th:field="*{effectiveFrom}" placeholder="適用開始"></div>
                  <div class="col-4"><input class="form-control form-control-sm" type="date" th:field="*{effectiveTo}" placeholder="適用終了"></div>
                  <div class="col-2"><input class="form-control form-control-sm" type="number" th:field="*{priority}" placeholder="優先"></div>
                  <div class="col-2"><div class="form-check mt-1"><input class="form-check-input" type="checkbox" th:field="*{active}" id="weeklyActive"><label class="form-check-label" for="weeklyActive">有効</label></div></div>
                </div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
                <button type="submit" class="btn btn-primary">追加</button>
              </div>
            </form>
          </div>
        </div>
      </div>

      <div class="mt-2" th:if="${mode}=='weekly'">
        <button class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#weeklyPlanAddModal">作業追加</button>
      </div>

      <!-- 特異日追加モーダル -->
      <div class="modal fade" id="specialAddModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">特異日を追加</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form th:action="@{/tasks/plan/days}" method="post">
              <div class="modal-body">
                <div class="row g-2 mb-2">
                  <div class="col-4"><input class="form-control form-control-sm" name="store" placeholder="店舗" th:value="${storeCode}" required></div>
                  <div class="col-4"><input class="form-control form-control-sm" type="date" name="date" required></div>
                  <div class="col-4"><input class="form-control form-control-sm" name="label" placeholder="特異日名" required></div>
                </div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">閉じる</button>
                <button type="submit" class="btn btn-primary">追加</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script th:inline="javascript">
    document.addEventListener('DOMContentLoaded', function() {
      const modeSelect = document.getElementById('modeSelect');
      const planForm = document.getElementById('planForm');
      const deptSelect = document.getElementById('deptSelect');
      
      modeSelect.addEventListener('change', function() {
        planForm.submit();
      });

      if (deptSelect) {
        deptSelect.addEventListener('change', function () {
          planForm.submit();
        });
      }

      // === Grid builder ===
      const storeCode = /*[[${storeCode}]]*/ '';
      const mode = /*[[${mode}]]*/ 'weekly';
      const selectedDow = /*[[${day}]]*/ 1;
      const selectedDate = /*[[${sd}]]*/ null;
      const selectedDept = /*[[${dept}]]*/ '';
      const gridPlans = /*[[${gridPlans}]]*/ [];
      const masters = /*[[${masters}]]*/ [];
      const grid = document.getElementById('timeGrid');
      const planMap = {};
      const pendingCreates = [];
      const pendingUpdates = [];
      const pendingDeletes = [];
      let tempIdSeq = 1;
      // Feature flags
      const ENABLE_BLOCK_DRAG = true; // enable left-click drag-and-drop move; right-click opens edit dialog
      // Global resize state so global handlers can access it
      let resizeState = {
        active: false,
        row: null,
        planId: null,
        startCol: null,
        endCol: null,
        edge: null, // 'start' | 'end'
        taskCode: null,
        staff: 1,
        colorClass: 'task-cell-default',
        prev: null,
        conflicted: false
      };
      // Global move state for dragging entire blocks
      let moveState = {
        active: false,
        planId: null,
        baseRow: null,
        startCol: null,
        endCol: null,
        staff: 1,
        taskCode: null,
        colorClass: 'task-cell-default',
        offsetCols: 0,
        offsetRow: 0,
        prev: null,
        conflicted: false
      };
      if (grid && storeCode) {
        const cols = 96; // 24h * 4 (15min)
        const rows = 15; // lanes
        // Build template columns: 1 sticky label + 96 slots
        grid.style.gridTemplateColumns = `60px repeat(${cols}, 50px)`;

        // Common metrics for pixel positioning
        const SLOT_PX = 50;   // per 15-min slot
        const LABEL_PX = 60;  // left sticky label width
        const ROW_PX = 28;    // row height
        const HEADER_PX = 28; // header row height

        // Header row
        const headerLabel = document.createElement('div');
        headerLabel.className = 'header';
        headerLabel.textContent = '';
        grid.appendChild(headerLabel);
        for (let h = 0; h < 24; h++) {
          const hourCell = document.createElement('div');
          hourCell.className = 'header header-hour';
          hourCell.style.gridColumn = `span 4`;
          hourCell.textContent = `${String(h).padStart(2,'0')}:00`;
          grid.appendChild(hourCell);
        }

        // Drag state
        const dragState = {
          active: false,
          row: null,
          startCol: null,
          endCol: null,
          highlighted: []
        };

        // (moved) resizeState is defined in outer scope for global handlers

        function clearHighlight() {
          for (const el of dragState.highlighted) el.classList.remove('selecting');
          dragState.highlighted = [];
        }
        function highlightRange(rowIndex, c1, c2) {
          clearHighlight();
          const from = Math.min(c1, c2);
          const to = Math.max(c1, c2);
          const rowStartIndex = (1 /*header*/ + rowIndex + 1) * (cols + 1); // Not used; we'll query by dataset
          const cells = grid.querySelectorAll(`.cell[data-row="${rowIndex}"]`);
          for (let i = from; i <= to; i++) {
            const el = Array.from(cells).find(x => Number(x.dataset.col) === i);
            if (el) {
              el.classList.add('selecting');
              dragState.highlighted.push(el);
            }
          }
        }

        // Utility: find contiguous block bounds for a given cell
        function getBlockBounds(rowIndex, colIndex, pid) {
          let start = colIndex;
          let end = colIndex + 1;
          for (let c = colIndex - 1; c >= 0; c--) {
            const el = document.querySelector(`.cell[data-row="${rowIndex}"][data-col="${c}"]`);
            if (!el || el.dataset.planId !== pid) break;
            start = c;
          }
          for (let c = colIndex + 1; c < cols; c++) {
            const el = document.querySelector(`.cell[data-row="${rowIndex}"][data-col="${c}"]`);
            if (!el || el.dataset.planId !== pid) break;
            end = c + 1;
          }
          return { start, end };
        }

        // Utility: create/update a single block element spanning time slots and lanes
        function createOrUpdateBlock(rowIndex, pid, fromCol, toColExclusive, taskCode, staff, colorClass, labelStart, labelEnd) {
          let block = document.getElementById(`plan-block-${pid}`);
          const left = LABEL_PX + fromCol * SLOT_PX;
          const top = HEADER_PX + rowIndex * ROW_PX;
          const width = Math.max(1, (toColExclusive - fromCol)) * SLOT_PX;
          const height = Math.max(1, staff) * ROW_PX;
          const taskName = getTaskName(taskCode);
          const timeLabel = (labelStart && labelEnd) ? `${labelStart} - ${labelEnd}` : '';
          if (!block) {
            block = document.createElement('div');
            block.id = `plan-block-${pid}`;
            block.className = `plan-block ${colorClass}`;
            grid.appendChild(block);
          } else {
            // Update color class keeping base
            block.className = `plan-block ${colorClass}`;
          }
          block.style.left = `${left}px`;
          block.style.top = `${top}px`;
          block.style.width = `${width}px`;
          block.style.height = `${height}px`;
          block.dataset.planId = String(pid);
          block.dataset.taskCode = taskCode;
          block.dataset.staff = String(staff);
          block.dataset.row = String(rowIndex);
          block.dataset.startCol = String(fromCol);
          block.dataset.endCol = String(toColExclusive);
          block.innerHTML = `<div class="task-label" title="${taskName} ${timeLabel ? '('+timeLabel+')' : ''}">${taskName}</div><div class="resize-handle"></div>`;
        }

        // Create/update a semi-transparent flexible window overlay
        function createOrUpdateWindow(rowIndex, pid, fromCol, toColExclusive, staff, colorClass) {
          if (!(fromCol >= 0) || !(toColExclusive > fromCol)) return;
          let overlay = document.getElementById(`plan-window-${pid}`);
          const left = LABEL_PX + fromCol * SLOT_PX;
          const top = HEADER_PX + rowIndex * ROW_PX;
          const width = Math.max(1, (toColExclusive - fromCol)) * SLOT_PX;
          const height = Math.max(1, staff) * ROW_PX;
          if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = `plan-window-${pid}`;
            overlay.className = `plan-window ${colorClass}`;
            grid.appendChild(overlay);
          } else {
            overlay.className = `plan-window ${colorClass}`;
          }
          overlay.style.left = `${left}px`;
          overlay.style.top = `${top}px`;
          overlay.style.width = `${width}px`;
          overlay.style.height = `${height}px`;
          overlay.dataset.planId = String(pid);
          overlay.dataset.row = String(rowIndex);
          overlay.dataset.startCol = String(fromCol);
          overlay.dataset.endCol = String(toColExclusive);
        }

        // Ensure only one handle exists inside the block
        function setSingleHandle(pid, endColExclusive) {
          const block = document.getElementById(`plan-block-${pid}`);
          if (!block) return;
          // Ensure handle exists
          let handle = block.querySelector('.resize-handle');
          if (!handle) {
            handle = document.createElement('div');
            handle.className = 'resize-handle';
            block.appendChild(handle);
          }
        }

        // Utility: get all row indices currently occupied by a plan id (from block)
        function getRowsForPlan(pid) {
          const block = document.getElementById(`plan-block-${pid}`);
          if (!block) return [];
          const base = Number(block.dataset.row || '0');
          const staff = Number(block.dataset.staff || '1');
          const rows = [];
          for (let r = 0; r < staff; r++) rows.push(base + r);
          return rows;
        }

        // Conflict detection using existing blocks
        function hasConflict(rowIndex, fromCol, toColExclusive, ignorePlanId) {
          const staff = 1; // single lane by default in this context
          return hasBlockConflict(rowIndex, staff, fromCol, toColExclusive, ignorePlanId);
        }
        function hasBlockConflict(baseRow, staff, fromCol, toColExclusive, ignorePlanId) {
          const blocks = Array.from(document.querySelectorAll('.plan-block'));
          const myRows = new Set();
          for (let r = 0; r < staff; r++) myRows.add(baseRow + r);
          for (const b of blocks) {
            const pid = b.dataset.planId;
            if (ignorePlanId && pid === String(ignorePlanId)) continue;
            const bRow = Number(b.dataset.row || '0');
            const bStaff = Number(b.dataset.staff || '1');
            const bStart = Number(b.dataset.startCol || '0');
            const bEnd = Number(b.dataset.endCol || '0');
            for (let r = 0; r < bStaff; r++) {
              const rr = bRow + r;
              if (myRows.has(rr)) {
                // Overlap in time?
                if (fromCol < bEnd && toColExclusive > bStart) {
                  return true;
                }
              }
            }
          }
          return false;
        }

        function finalizeRange() {
          if (!dragState.active || dragState.row == null || dragState.startCol == null || dragState.endCol == null) { dragState.active = false; clearHighlight(); return; }
          const dept = selectedDept;
          const task = document.getElementById('gridTask').value;
          const dowEl = document.getElementById('gridDow');
          const dateEl = document.getElementById('gridDate');
          if (!dept) { alert('部門を選択してください'); dragState.active = false; clearHighlight(); return; }
          if (!task) { alert('作業マスタを選択してください'); dragState.active = false; clearHighlight(); return; }
          const fromCol = Math.min(dragState.startCol, dragState.endCol);
          const toColExclusive = Math.max(dragState.startCol, dragState.endCol) + 1;
          const { start, end } = timesFromRange(fromCol, toColExclusive);
          // Conflict check: don't register over existing blocks
          if (hasConflict(dragState.row, fromCol, toColExclusive)) {
            // silently ignore overlapping registration
            dragState.active = false;
            clearHighlight();
            return;
          }
          // Stage pending create and paint locally
          const tempId = `new-${tempIdSeq++}`;
          const pending = { tempId, mode, storeCode, departmentCode: dept, taskCode: task, scheduleType: 'FIXED', fixedStartTime: start, fixedEndTime: end, requiredStaffCount: 1, lane: (dragState.row + 1) };
          if (mode === 'weekly') {
            const dow = dowEl ? Number(dowEl.value || selectedDow || 1) : (selectedDow || 1);
            pending.dayOfWeek = dow;
          } else {
            const d = (dateEl && dateEl.value) ? dateEl.value : (selectedDate ? formatDate(selectedDate) : '');
            if (!d) { alert('特異日を選択してください'); dragState.active = false; clearHighlight(); return; }
            pending.specialDate = d;
          }
          pendingCreates.push(pending);
          // Draw single plan block
          const taskColorClass = getTaskColorClass(task);
          createOrUpdateBlock(dragState.row, tempId, fromCol, toColExclusive, task, 1, taskColorClass, start, end);
          setSingleHandle(tempId, toColExclusive);
          dragState.active = false;
          clearHighlight();
        }

        document.addEventListener('mouseup', () => {
          if (resizeState.active) {
            // If conflicted during resize, revert to previous state and alert
            if (resizeState.conflicted && resizeState.prev) {
              const pid = resizeState.planId;
              const prev = resizeState.prev;
              const plan = planMap[pid] || {};
              const timesPrev = timesFromRange(prev.startCol, prev.endCol);
              createOrUpdateBlock(prev.baseRow, pid, prev.startCol, prev.endCol, resizeState.taskCode, prev.staff, resizeState.colorClass, timesPrev.start, timesPrev.end);
              if (plan.scheduleType === 'FLEXIBLE') {
                const ws = timeToSlot(plan.windowStartTime);
                const we = timeToSlot(plan.windowEndTime);
                if (ws >= 0 && we > ws) {
                  createOrUpdateWindow(prev.baseRow, pid, ws, we, prev.staff, resizeState.colorClass);
                }
              }
              try { setSingleHandle(pid, prev.endCol); } catch {}
              try { const blk = document.getElementById(`plan-block-${pid}`); if (blk) blk.style.pointerEvents = ''; } catch {}
              showInlineWarning('他の作業と重なっています。元の位置に戻します。');
              // Reset
              resizeState.active = false;
              resizeState.row = null; resizeState.planId = null;
              resizeState.startCol = null; resizeState.endCol = null; resizeState.edge = null;
              resizeState.prev = null; resizeState.conflicted = false;
              return;
            }
            // Finalize visual resize: stage update
            const row = resizeState.row;
            const pid = resizeState.planId;
            const times = timesFromRange(resizeState.startCol, resizeState.endCol);
            // If this was a new staged plan
            if (String(pid).startsWith('new-')) {
              const idx = pendingCreates.findIndex(x => x.tempId === pid);
              if (idx >= 0) {
                const c = pendingCreates[idx];
                c.scheduleType = 'FIXED';
                c.fixedStartTime = times.start;
                c.fixedEndTime = times.end;
                c.lane = row + 1;
                c.requiredStaffCount = resizeState.staff;
                pendingCreates[idx] = c;
              }
            } else {
              // Stage an update for existing plan (FIXED or FLEXIBLE duration)
              const plan = planMap[pid] || {};
              if (plan.scheduleType === 'FLEXIBLE') {
                const durationMin = (resizeState.endCol - resizeState.startCol) * 15;
                pendingUpdates.push({ planId: pid, scheduleType: 'FLEXIBLE', requiredDurationMinutes: durationMin, requiredStaffCount: resizeState.staff, lane: row + 1, active: true });
              } else {
                pendingUpdates.push({ planId: pid, scheduleType: 'FIXED', fixedStartTime: times.start, fixedEndTime: times.end, requiredStaffCount: resizeState.staff, lane: row + 1, active: true });
              }
            }
            // Update planMap projected values
            const p = planMap[pid] || {};
            if (p.scheduleType === 'FLEXIBLE') {
              p.requiredDurationMinutes = (resizeState.endCol - resizeState.startCol) * 15;
            } else {
              p.scheduleType = 'FIXED';
              p.fixedStartTime = times.start; p.fixedEndTime = times.end;
            }
            p.requiredStaffCount = resizeState.staff; p.lane = row + 1;
            planMap[pid] = p;
            // Restore the single bottom-right resize handle for this plan after finalize
            try { setSingleHandle(pid, resizeState.endCol); } catch (e) {}
            // If FLEXIBLE, also update the window overlay height to match staff
            try {
              const plan = planMap[pid] || {};
              if (plan.scheduleType === 'FLEXIBLE') {
                const winStart = timeToSlot(plan.windowStartTime);
                const winEnd = timeToSlot(plan.windowEndTime);
                if (winStart >= 0 && winEnd > winStart) {
                  createOrUpdateWindow(row, pid, winStart, winEnd, resizeState.staff, getTaskColorClass(resizeState.taskCode));
                }
              }
            } catch (e) {}
            // Re-enable pointer events on the resized block
            try { const blk = document.getElementById(`plan-block-${pid}`); if (blk) blk.style.pointerEvents = ''; } catch {}

            // Reset
            resizeState.active = false;
            resizeState.row = null; resizeState.planId = null;
            resizeState.startCol = null; resizeState.endCol = null; resizeState.edge = null;
            resizeState.prev = null; resizeState.conflicted = false;
            return;
          }
          if (ENABLE_BLOCK_DRAG && moveState.active) {
            // If conflicted during move, revert to previous state and alert
            if (moveState.conflicted && moveState.prev) {
              const pid = moveState.planId;
              const prev = moveState.prev;
              const plan = planMap[pid] || {};
              const timesPrev = timesFromRange(prev.startCol, prev.endCol);
              createOrUpdateBlock(prev.baseRow, pid, prev.startCol, prev.endCol, moveState.taskCode, prev.staff, moveState.colorClass, timesPrev.start, timesPrev.end);
              if (plan.scheduleType === 'FLEXIBLE') {
                const ws = timeToSlot(plan.windowStartTime);
                const we = timeToSlot(plan.windowEndTime);
                if (ws >= 0 && we > ws) {
                  createOrUpdateWindow(prev.baseRow, pid, ws, we, prev.staff, moveState.colorClass);
                }
              }
              try { setSingleHandle(pid, prev.endCol); } catch {}
              try { const blk = document.getElementById(`plan-block-${pid}`); if (blk) blk.style.pointerEvents = ''; } catch {}
              showInlineWarning('他の作業と重なっています。元の位置に戻します。');
              moveState.active = false;
              moveState.planId = null; moveState.baseRow = null;
              moveState.startCol = null; moveState.endCol = null;
              moveState.offsetCols = 0; moveState.offsetRow = 0;
              moveState.prev = null; moveState.conflicted = false;
              return;
            }
            const pid = moveState.planId;
            const row = moveState.baseRow;
            const plan = planMap[pid] || {};
            const times = timesFromRange(moveState.startCol, moveState.endCol);
            if (!String(pid).startsWith('new-')) {
              if (plan.scheduleType === 'FLEXIBLE') {
                // Persist lane/staff only for move; duration unchanged
                pendingUpdates.push({ planId: pid, scheduleType: 'FLEXIBLE', requiredDurationMinutes: plan.requiredDurationMinutes, requiredStaffCount: moveState.staff, lane: row + 1, active: true });
              } else {
                pendingUpdates.push({ planId: pid, scheduleType: 'FIXED', fixedStartTime: times.start, fixedEndTime: times.end, requiredStaffCount: moveState.staff, lane: row + 1, active: true });
              }
            } else {
              const idx = pendingCreates.findIndex(x => x.tempId === pid);
              if (idx >= 0) {
                const c = pendingCreates[idx];
                c.lane = row + 1;
                if (c.scheduleType === 'FIXED') { c.fixedStartTime = times.start; c.fixedEndTime = times.end; }
                pendingCreates[idx] = c;
              }
            }
            // Update planMap
            const p = planMap[pid] || {};
            if (p.scheduleType === 'FIXED') { p.fixedStartTime = times.start; p.fixedEndTime = times.end; }
            p.requiredStaffCount = moveState.staff; p.lane = row + 1;
            planMap[pid] = p;
            // Re-enable pointer events
            try { const blk = document.getElementById(`plan-block-${pid}`); if (blk) blk.style.pointerEvents = ''; } catch {}
            // Reset
            moveState.active = false;
            moveState.planId = null; moveState.baseRow = null;
            moveState.startCol = null; moveState.endCol = null;
            moveState.offsetCols = 0; moveState.offsetRow = 0;
            moveState.prev = null; moveState.conflicted = false;
            return;
          }
          finalizeRange();
        });

        // Helper: open edit modal for a given filled cell
        function openEditForCell(cell) {
          currentCtxCell = cell;
          const pid = cell.dataset.planId;
          const row = Number(cell.dataset.row);
          // Determine contiguous block of the same plan in the row
          const col = Number(cell.dataset.col);
          let start = col;
          let end = col + 1;
          for (let c = col - 1; c >= 0; c--) {
            const el = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
            if (!el || el.dataset.planId !== pid) break;
            start = c;
          }
          for (let c = col + 1; c < 96; c++) {
            const el = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
            if (!el || el.dataset.planId !== pid) break;
            end = c + 1;
          }
          const range = timesFromRange(start, end);
          // Prefill schedule type & fields
          const plan = planMap[pid] || {};
          const scheduleType = plan.scheduleType || 'FIXED';
          const scheduleTypeEl = document.getElementById('editScheduleType');
          if (scheduleTypeEl) scheduleTypeEl.value = scheduleType;
          toggleScheduleGroups(scheduleType);
          if (scheduleType === 'FIXED') {
            document.getElementById('editStart').value = range.start;
            document.getElementById('editEnd').value = range.end;
          } else {
            document.getElementById('editWinStart').value = plan.windowStartTime || '';
            document.getElementById('editWinEnd').value = plan.windowEndTime || '';
            document.getElementById('editDuration').value = plan.requiredDurationMinutes || '';
          }
          const staff = cell.dataset.staff ? Number(cell.dataset.staff) : (plan.requiredStaffCount || 1);
          document.getElementById('editStaff').value = String(staff);
          const active = cell.dataset.active ? (cell.dataset.active === 'true') : true;
          document.getElementById('editActive').checked = active;
          document.getElementById('editNote').value = plan.note || '';
          try {
            editModal = editModal || new bootstrap.Modal(editModalEl);
            editModal.show();
          } catch (e) {
            console.warn('Bootstrap modal not available', e);
          }
        }

        // Body rows
        for (let r = 0; r < rows; r++) {
          const label = document.createElement('div');
          label.className = 'row-label';
          label.textContent = `Lane ${r+1}`;
          grid.appendChild(label);
          for (let c = 0; c < cols; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = String(r);
            cell.dataset.col = String(c);
            cell.title = timeLabelFromSlot(c);
            cell.addEventListener('mousedown', (ev) => {
              // Left click
              if (ev.button === 0) {
                // If user grabbed the resize handle, don't trigger modal/drag-add here
                if (ev.target && ev.target.closest && ev.target.closest('.resize-handle')) {
                  // Let the global handle listener take over
                  return;
                }
                // If cell already filled, open modal (resize is handled by handle)
                if (cell.classList.contains('filled')) {
                  openEditForCell(cell);
                  ev.preventDefault();
                  return;
                }
                // Start drag-add on empty cells only
                const dept = selectedDept;
                const task = document.getElementById('gridTask').value;
                if (!dept || !task) {
                  alert(!dept ? '部門を選択してください' : '作業マスタを選択してください');
                  return;
                }
                dragState.active = true;
                dragState.row = Number(cell.dataset.row);
                dragState.startCol = Number(cell.dataset.col);
                dragState.endCol = Number(cell.dataset.col);
                highlightRange(dragState.row, dragState.startCol, dragState.endCol);
                ev.preventDefault();
                return;
              }
              // Right button is handled by contextmenu listener below
            });
            cell.addEventListener('mouseenter', () => {
              const row = Number(cell.dataset.row);
              // Move in-progress (disabled unless ENABLE_BLOCK_DRAG)
              if (ENABLE_BLOCK_DRAG && moveState.active) {
                const plan = planMap[moveState.planId] || {};
                const isFlexible = (plan.scheduleType === 'FLEXIBLE');
                const widthSlots = moveState.endCol - moveState.startCol;
                // Initialize offsets on first hover
                if (moveState.offsetCols === 0 && moveState.offsetRow === 0) {
                  moveState.offsetCols = Number(cell.dataset.col) - moveState.startCol;
                  moveState.offsetRow = Number(cell.dataset.row) - moveState.baseRow;
                }
                let targetBaseRow = Number(cell.dataset.row) - moveState.offsetRow;
                let targetStart = Number(cell.dataset.col) - moveState.offsetCols;
                if (isNaN(targetBaseRow)) targetBaseRow = moveState.baseRow;
                if (isNaN(targetStart)) targetStart = moveState.startCol;
                // clamp rows by staff
                targetBaseRow = Math.max(0, Math.min(15 - moveState.staff, targetBaseRow));
                // clamp columns
                const cols = 96;
                targetStart = Math.max(0, Math.min(cols - widthSlots, targetStart));
                let targetEnd = targetStart + widthSlots;
                if (isFlexible) {
                  const winStart = timeToSlot(plan.windowStartTime);
                  const winEnd = timeToSlot(plan.windowEndTime);
                  if (winStart >= 0 && winEnd > winStart) {
                    if (targetStart < winStart) { targetStart = winStart; targetEnd = targetStart + widthSlots; }
                    if (targetEnd > winEnd) { targetEnd = winEnd; targetStart = targetEnd - widthSlots; }
                  }
                }
                // conflict check
                if (!hasBlockConflict(targetBaseRow, moveState.staff, targetStart, targetEnd, moveState.planId)) {
                  const times = timesFromRange(targetStart, targetEnd);
                  createOrUpdateBlock(targetBaseRow, moveState.planId, targetStart, targetEnd, moveState.taskCode, moveState.staff, moveState.colorClass, times.start, times.end);
                  if (isFlexible) {
                    const winStart = timeToSlot(plan.windowStartTime);
                    const winEnd = timeToSlot(plan.windowEndTime);
                    if (winStart >= 0 && winEnd > winStart) {
                      createOrUpdateWindow(targetBaseRow, moveState.planId, winStart, winEnd, moveState.staff, moveState.colorClass);
                    }
                  }
                  try { setSingleHandle(moveState.planId, targetEnd); } catch {}
                  moveState.baseRow = targetBaseRow;
                  moveState.startCol = targetStart;
                  moveState.endCol = targetEnd;
                  moveState.conflicted = false;
                } else {
                  moveState.conflicted = true;
                }
                return;
              }
              // Resize in-progress
              if (resizeState.active) {
                const col = Number(cell.dataset.col);
                let newStart = resizeState.startCol;
                let newEnd = resizeState.endCol;
                // Determine base row and current/new staff across lanes
                const rowsForPlan = getRowsForPlan(resizeState.planId);
                const baseRow = rowsForPlan.length > 0 ? Math.min(...rowsForPlan) : resizeState.row;
                let newStaff = resizeState.staff;
                if (row >= baseRow) {
                  newStaff = Math.min(row - baseRow + 1, 15 - baseRow);
                  if (newStaff < 1) newStaff = 1;
                }
                const plan = planMap[resizeState.planId] || {};
                const isFlexible = (plan.scheduleType === 'FLEXIBLE');
                const winStartSlot = isFlexible ? timeToSlot(plan.windowStartTime) : null;
                const winEndSlot = isFlexible ? timeToSlot(plan.windowEndTime) : null;
                if (resizeState.edge === 'start') {
                  // Propose newStart, ensure at least 1 slot
                  newStart = Math.min(col, resizeState.endCol - 1);
                  // If proposed overlaps, flag and bail (revert on mouseup)
                  const conflictStart = hasBlockConflict(baseRow, newStaff, newStart, resizeState.endCol, resizeState.planId);
                  if (conflictStart) { resizeState.conflicted = true; return; }
                  // Clamp against conflicts across all lanes using block-level check
                  while (hasBlockConflict(baseRow, newStaff, newStart, resizeState.endCol, resizeState.planId)) {
                    newStart++;
                    if (newStart >= resizeState.endCol) { newStart = resizeState.endCol - 1; break; }
                  }
                  // For FLEXIBLE, ensure start stays within window start
                  if (isFlexible && winStartSlot !== null) {
                    if (newStart < winStartSlot) newStart = winStartSlot;
                  }
                } else if (resizeState.edge === 'end') {
                  newEnd = Math.max(col + 1, resizeState.startCol + 1);
                  // If proposed overlaps, flag and bail (revert on mouseup)
                  const conflictEnd = hasBlockConflict(baseRow, newStaff, resizeState.startCol, newEnd, resizeState.planId);
                  if (conflictEnd) { resizeState.conflicted = true; return; }
                  while (hasBlockConflict(baseRow, newStaff, resizeState.startCol, newEnd, resizeState.planId)) {
                    newEnd--;
                    if (newEnd <= resizeState.startCol) { newEnd = resizeState.startCol + 1; break; }
                  }
                  // Ensure non-empty
                  if (newEnd <= resizeState.startCol) newEnd = resizeState.startCol + 1;
                  // For FLEXIBLE, ensure end stays within window end
                  if (isFlexible && winEndSlot !== null) {
                    if (newEnd > winEndSlot) newEnd = winEndSlot;
                  }
                }
                // Repaint only if changed
                if (newStart !== resizeState.startCol || newEnd !== resizeState.endCol || newStaff !== resizeState.staff) {
                  const times = timesFromRange(newStart, newEnd);
                  // Update duration block
                  createOrUpdateBlock(baseRow, resizeState.planId, newStart, newEnd, resizeState.taskCode, newStaff, resizeState.colorClass, times.start, times.end);
                  // If FLEXIBLE, also update window overlay height and bounds
                  if (isFlexible && winStartSlot !== null && winEndSlot !== null && winEndSlot > winStartSlot) {
                    createOrUpdateWindow(baseRow, resizeState.planId, winStartSlot, winEndSlot, newStaff, resizeState.colorClass);
                  }
                  // Restore the single bottom-right handle for this plan during live resize
                  try { setSingleHandle(resizeState.planId, newEnd); } catch (e) {}
                  resizeState.startCol = newStart;
                  resizeState.endCol = newEnd;
                  resizeState.staff = newStaff;
                }
                return;
              }
              // Drag-add in-progress
              if (!dragState.active) return;
              if (row !== dragState.row) return; // restrict to same row selection
              dragState.endCol = Number(cell.dataset.col);
              highlightRange(dragState.row, dragState.startCol, dragState.endCol);
            });
            // Disable right-click per cell
            cell.addEventListener('contextmenu', (ev) => { ev.preventDefault(); return; });
            grid.appendChild(cell);
          }
        }

        // Load and display existing plans
        loadExistingPlans();
      }

      function loadExistingPlans() {
        if (!gridPlans || gridPlans.length === 0) {
          return;
        }

        // Create a map of task codes to names
        const taskNameMap = {};
        if (masters) {
          masters.forEach(m => {
            taskNameMap[m.taskCode] = m.name || m.taskCode;
          });
        }

        gridPlans.forEach((plan, index) => {
          if (plan && plan.planId) {
            planMap[String(plan.planId)] = plan;
          }
          const baseRow = (plan.lane && plan.lane >= 1 && plan.lane <= 15) ? (plan.lane - 1) : (index % 15);
          const staffCnt = Math.max(1, Number(plan.requiredStaffCount || 1));
          const taskColorClass = getTaskColorClass(plan.taskCode);
          const scheduleType = plan.scheduleType || 'FIXED';
          if (scheduleType === 'FIXED') {
            if (!plan.fixedStartTime || !plan.fixedEndTime) return;
            const startSlot = timeToSlot(plan.fixedStartTime);
            const endSlot = timeToSlot(plan.fixedEndTime);
            if (startSlot >= 0 && endSlot > startSlot) {
              const range = timesFromRange(startSlot, endSlot);
              createOrUpdateBlock(baseRow, plan.planId, startSlot, endSlot, plan.taskCode, staffCnt, taskColorClass, range.start, range.end);
              setSingleHandle(plan.planId, endSlot);
              // remove any window overlay if present
              const oldWin = document.getElementById(`plan-window-${plan.planId}`);
              if (oldWin) oldWin.remove();
            }
          } else {
            // FLEXIBLE: show window as semi-transparent overlay; bar length = requiredDurationMinutes
            const winStartSlot = timeToSlot(plan.windowStartTime);
            const winEndSlot = timeToSlot(plan.windowEndTime);
            const durationMin = Number(plan.requiredDurationMinutes || 0);
            const durationSlots = Math.max(1, Math.ceil(durationMin / 15));
            if (winStartSlot >= 0 && winEndSlot > winStartSlot) {
              createOrUpdateWindow(baseRow, plan.planId, winStartSlot, winEndSlot, staffCnt, taskColorClass);
              const blockStart = winStartSlot;
              const blockEnd = Math.min(winStartSlot + durationSlots, winEndSlot);
              createOrUpdateBlock(baseRow, plan.planId, blockStart, blockEnd, plan.taskCode, staffCnt, taskColorClass, null, null);
              // Add handle for FLEXIBLE to adjust duration length
              setSingleHandle(plan.planId, blockEnd);
            }
          }
        });
      }

      // ===== Task tree (always visible) =====
      function buildCategoryMap(list) {
        const map = new Map();
        if (!Array.isArray(list)) return map;
        list.forEach(m => {
          const code = m.categoryCode || '__UNCAT__';
          const name = m.categoryName || '未分類';
          if (!map.has(code)) map.set(code, { code, name, tasks: [] });
          map.get(code).tasks.push({ code: m.taskCode, name: m.name, departmentCode: m.departmentCode });
        });
        // sort categories by name, tasks by name
        const sorted = Array.from(map.values()).sort((a,b)=>a.name.localeCompare(b.name));
        sorted.forEach(cat => cat.tasks.sort((a,b)=>a.name.localeCompare(b.name)));
        return sorted;
      }
      function renderTaskTree() {
        try {
          const listEl = document.getElementById('taskTreeList');
          if (!listEl) return;
          listEl.innerHTML = '';
          const cats = buildCategoryMap(masters);
          if (!cats || cats.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'list-group-item text-muted';
            empty.textContent = '作業マスタがありません';
            listEl.appendChild(empty);
            return;
          }
          cats.forEach(cat => {
            const catItem = document.createElement('button');
            catItem.type = 'button';
            catItem.className = 'list-group-item list-group-item-action category';
            const chev = document.createElement('span'); chev.className = 'chev';
            const label = document.createElement('span'); label.textContent = cat.name;
            catItem.appendChild(chev); catItem.appendChild(label);
            listEl.appendChild(catItem);
            const ul = document.createElement('div'); ul.style.display = ''; // default open
            cat.tasks.forEach(t => {
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'list-group-item list-group-item-action task';
              btn.textContent = `${t.code} - ${t.name}`;
              btn.dataset.taskCode = t.code;
              btn.addEventListener('click', () => {
                const hid = document.getElementById('gridTask');
                if (hid) hid.value = t.code;
                // highlight selection
                document.querySelectorAll('.task-tree .list-group-item.task.selected').forEach(e => e.classList.remove('selected'));
                btn.classList.add('selected');
                const lbl = document.getElementById('selectedTaskLabel');
                if (lbl) lbl.textContent = `${t.name} (${t.code})`;
              });
              ul.appendChild(btn);
            });
            listEl.appendChild(ul);
            catItem.addEventListener('click', () => {
              const open = ul.style.display !== 'none';
              ul.style.display = open ? 'none' : '';
              chev.classList.toggle('open', !open);
            });
            // default open chevron
            chev.classList.add('open');
          });
        } catch (e) { console.warn('renderTaskPicker error', e); }
      }
      // Build task tree
      renderTaskTree();

      // Rebuild traditional selects to use optgroup hierarchy
      function rebuildTaskSelects() {
        const cats = buildCategoryMap(masters);
        document.querySelectorAll('select.task-select').forEach(sel => {
          const current = sel.value;
          sel.innerHTML = '';
          const def = document.createElement('option'); def.value=''; def.textContent='選択してください'; sel.appendChild(def);
          cats.forEach(cat => {
            const og = document.createElement('optgroup'); og.label = cat.name;
            cat.tasks.forEach(t => {
              const opt = document.createElement('option'); opt.value = t.code; opt.textContent = `${t.code} - ${t.name}`;
              og.appendChild(opt);
            });
            sel.appendChild(og);
          });
          if (current) sel.value = current;
        });
      }
      rebuildTaskSelects();

      function timeToSlot(timeStr) {
        if (!timeStr) return -1;
        try {
          let hours, minutes;
          // If already a Date object
          if (timeStr instanceof Date) {
            hours = timeStr.getHours();
            minutes = timeStr.getMinutes();
          } else if (typeof timeStr === 'string') {
            const s = timeStr.trim();
            // Pure HH:mm or HH:mm:ss
            const hhmm = /^\d{1,2}:\d{2}$/;
            const hhmmss = /^\d{1,2}:\d{2}:\d{2}$/;
            if (hhmm.test(s) || hhmmss.test(s)) {
              const parts = s.split(':');
              hours = parseInt(parts[0], 10);
              minutes = parseInt(parts[1], 10);
            } else {
              // Likely ISO or full datetime → let Date parse
              const d = new Date(s);
              if (isNaN(d.getTime())) return -1;
              hours = d.getHours();
              minutes = d.getMinutes();
            }
          } else {
            // Fallback: construct Date from value
            const d = new Date(timeStr);
            if (isNaN(d.getTime())) return -1;
            hours = d.getHours();
            minutes = d.getMinutes();
          }
          return Math.floor((hours * 60 + minutes) / 15);
        } catch (e) {
          console.warn(`timeToSlot error for ${timeStr}:`, e);
          return -1;
        }
      }

      // Context menu handlers and modal editing for grid blocks
      const ctxMenu = document.getElementById('planCtxMenu');
      const ctxEditBtn = document.getElementById('ctxEditBtn');
      const ctxDeleteBtn = document.getElementById('ctxDeleteBtn');
      const editModalEl = document.getElementById('planEditModal');
      let editModal = null;
      let currentCtxCell = null; // may hold a cell or a plan-block element

      function closeContextMenu() {
        if (ctxMenu) ctxMenu.style.display = 'none';
      }
      function openContextMenu(x, y, cell) {
        currentCtxCell = cell;
        if (!ctxMenu) return;
        ctxMenu.style.left = `${x}px`;
        ctxMenu.style.top = `${y}px`;
        ctxMenu.style.display = 'block';
      }

      document.addEventListener('click', (e) => {
        if (ctxMenu && ctxMenu.style.display === 'block') {
          const inside = e.target === ctxMenu || ctxMenu.contains(e.target);
          if (!inside) closeContextMenu();
        }
      });

      // Right-click on a plan block opens the edit dialog
      document.addEventListener('contextmenu', (ev) => {
        const block = ev.target.closest && ev.target.closest('.plan-block');
        if (!block) return;
        ev.preventDefault();
        currentCtxCell = block;
        // Inline open logic
        const pid = block.dataset.planId;
        const plan = planMap[pid] || {};
        const scheduleType = plan.scheduleType || 'FIXED';
        const scheduleTypeEl = document.getElementById('editScheduleType');
        scheduleTypeEl.value = scheduleType;
        toggleScheduleGroups(scheduleType);
        const start = Number(block.dataset.startCol || '0');
        const end = Number(block.dataset.endCol || '0');
        if (scheduleType === 'FIXED') {
          const range = timesFromRange(start, end);
          document.getElementById('editStart').value = range.start;
          document.getElementById('editEnd').value = range.end;
        } else {
          document.getElementById('editWinStart').value = plan.windowStartTime || '';
          document.getElementById('editWinEnd').value = plan.windowEndTime || '';
          document.getElementById('editDuration').value = plan.requiredDurationMinutes || '';
        }
        const staff = block.dataset.staff ? Number(block.dataset.staff) : (plan.requiredStaffCount || 1);
        document.getElementById('editStaff').value = String(staff);
        const active = block.dataset.active ? (block.dataset.active === 'true') : true;
        document.getElementById('editActive').checked = active;
        document.getElementById('editNote').value = plan.note || '';
        try {
          editModal = editModal || new bootstrap.Modal(editModalEl);
          editModal.show();
        } catch (e) {
          console.warn('Bootstrap modal not available', e);
        }
      });

      // Disable left-click edit when drag is enabled; keep for non-drag mode
      document.addEventListener('click', (ev) => {
        if (ENABLE_BLOCK_DRAG) return; // left-click used for drag, not modal
        const handle = ev.target.closest && ev.target.closest('.resize-handle');
        if (handle) return;
        const block = ev.target.closest && ev.target.closest('.plan-block');
        if (!block) return;
        currentCtxCell = block;
        if (ctxEditBtn) { try { ctxEditBtn.click(); return; } catch {} }
      });

      if (ctxEditBtn) {
        ctxEditBtn.addEventListener('click', () => {
          if (!currentCtxCell) return;
          const pid = currentCtxCell.dataset.planId;
          const plan = planMap[pid] || {};
          const scheduleType = plan.scheduleType || 'FIXED';
          const scheduleTypeEl = document.getElementById('editScheduleType');
          scheduleTypeEl.value = scheduleType;
          toggleScheduleGroups(scheduleType);
          let start, end, row;
          if (currentCtxCell.classList && currentCtxCell.classList.contains('plan-block')) {
            start = Number(currentCtxCell.dataset.startCol);
            end = Number(currentCtxCell.dataset.endCol);
            row = Number(currentCtxCell.dataset.row);
          } else {
            // Fallback for cell-based context
            row = Number(currentCtxCell.dataset.row);
            let col = Number(currentCtxCell.dataset.col);
            let s = col, e = col + 1;
            for (let c = col - 1; c >= 0; c--) {
              const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
              if (!cell || cell.dataset.planId !== pid) break;
              s = c;
            }
            for (let c = col + 1; c < 96; c++) {
              const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
              if (!cell || cell.dataset.planId !== pid) break;
              e = c + 1;
            }
            start = s; end = e;
          }
          if (scheduleType === 'FIXED') {
            const range = timesFromRange(start, end);
            document.getElementById('editStart').value = range.start;
            document.getElementById('editEnd').value = range.end;
          } else {
            document.getElementById('editWinStart').value = plan.windowStartTime || '';
            document.getElementById('editWinEnd').value = plan.windowEndTime || '';
            document.getElementById('editDuration').value = plan.requiredDurationMinutes || '';
          }
          const staff = currentCtxCell.dataset.staff ? Number(currentCtxCell.dataset.staff) : (plan.requiredStaffCount || 1);
          document.getElementById('editStaff').value = String(staff);
          const active = currentCtxCell.dataset.active ? (currentCtxCell.dataset.active === 'true') : true;
          document.getElementById('editActive').checked = active;
          document.getElementById('editNote').value = plan.note || '';
          closeContextMenu();
          try {
            editModal = editModal || new bootstrap.Modal(editModalEl);
            editModal.show();
          } catch (e) {
            console.warn('Bootstrap modal not available', e);
          }
        });
      }

      const scheduleTypeEl = document.getElementById('editScheduleType');
      function toggleScheduleGroups(type) {
        document.querySelectorAll('.fixed-group').forEach(el => el.style.display = (type === 'FIXED') ? '' : 'none');
        document.querySelectorAll('.flexible-group').forEach(el => el.style.display = (type === 'FLEXIBLE') ? '' : 'none');
      }
      if (scheduleTypeEl) {
        scheduleTypeEl.addEventListener('change', (e) => {
          const newType = e.target.value;
          // When switching from FIXED to FLEXIBLE in edit dialog, carry over start/end
          if (newType === 'FLEXIBLE') {
            const start = (document.getElementById('editStart')?.value || '').trim();
            const end = (document.getElementById('editEnd')?.value || '').trim();
            if (start && end) {
              const winStartEl = document.getElementById('editWinStart');
              const winEndEl = document.getElementById('editWinEnd');
              const durationEl = document.getElementById('editDuration');
              if (winStartEl) winStartEl.value = start;
              if (winEndEl) winEndEl.value = end;
              const ss = timeToSlot(start);
              const es = timeToSlot(end);
              if (durationEl && ss >= 0 && es > ss) {
                durationEl.value = String((es - ss) * 15);
              }
            }
          }
          toggleScheduleGroups(newType);
        });
      }

      // Start resize when dragging the bottom-right handle (supports plan-block)
      document.addEventListener('mousedown', (ev) => {
        const target = ev.target;
        if (!(target instanceof Element)) return;
        if (target.classList.contains('resize-handle')) {
          const parent = target.parentElement;
          if (!parent) return;
          // If resizing a plan-block
          if (parent.classList.contains('plan-block')) {
            const pid = parent.dataset.planId;
            const row = Number(parent.dataset.row);
            const plan = planMap[pid] || {};
            // Allow handle resize for FIXED and FLEXIBLE (duration) plans
            const start = Number(parent.dataset.startCol);
            const end = Number(parent.dataset.endCol);
            resizeState.active = true;
            resizeState.row = row;
            resizeState.planId = pid;
            resizeState.startCol = start;
            resizeState.endCol = end;
            resizeState.edge = 'end';
            resizeState.taskCode = parent.dataset.taskCode || '';
            resizeState.staff = parent.dataset.staff ? Number(parent.dataset.staff) : (plan.requiredStaffCount || 1);
            resizeState.colorClass = getTaskColorClass(resizeState.taskCode);
            resizeState.prev = { baseRow: row, startCol: start, endCol: end, staff: resizeState.staff };
            resizeState.conflicted = false;
            // Allow underlying cells to receive mouseenter during drag
            try { parent.style.pointerEvents = 'none'; } catch {}
            ev.preventDefault();
            ev.stopPropagation();
            return;
          }
          // Backward compatibility: if handle inside a cell (shouldn't happen after block migration)
          const cell = parent;
          const pid = cell.dataset.planId;
          const row = Number(cell.dataset.row);
          const plan = planMap[pid] || {};
          // Allow for FIXED and FLEXIBLE
          const col = Number(cell.dataset.col);
          // Compute contiguous block bounds for this plan id on this row
          let start = col;
          let end = col + 1;
          for (let c = col - 1; c >= 0; c--) {
            const el = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
            if (!el || el.dataset.planId !== pid) break;
            start = c;
          }
          for (let c = col + 1; c < 96; c++) {
            const el = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
            if (!el || el.dataset.planId !== pid) break;
            end = c + 1;
          }
          resizeState.active = true;
          resizeState.row = row;
          resizeState.planId = pid;
          resizeState.startCol = start;
          resizeState.endCol = end;
          resizeState.edge = 'end';
          resizeState.taskCode = cell.dataset.taskCode || '';
          resizeState.staff = cell.dataset.staff ? Number(cell.dataset.staff) : (plan.requiredStaffCount || 1);
          resizeState.colorClass = getTaskColorClass(resizeState.taskCode);
          resizeState.prev = { baseRow: row, startCol: start, endCol: end, staff: resizeState.staff };
          resizeState.conflicted = false;
          ev.preventDefault();
          ev.stopPropagation();
        }
        // Start move when dragging a plan-block (not the resize handle)
        const block = target.closest && target.closest('.plan-block');
        if (ENABLE_BLOCK_DRAG && block && !target.classList.contains('resize-handle')) {
          const pid = block.dataset.planId;
          const plan = planMap[pid] || {};
          moveState.active = true;
          moveState.planId = pid;
          moveState.baseRow = Number(block.dataset.row || '0');
          moveState.startCol = Number(block.dataset.startCol || '0');
          moveState.endCol = Number(block.dataset.endCol || '0');
          moveState.staff = block.dataset.staff ? Number(block.dataset.staff) : (plan.requiredStaffCount || 1);
          moveState.taskCode = block.dataset.taskCode || '';
          moveState.colorClass = getTaskColorClass(moveState.taskCode);
          moveState.offsetCols = 0; moveState.offsetRow = 0;
          moveState.prev = { baseRow: moveState.baseRow, startCol: moveState.startCol, endCol: moveState.endCol, staff: moveState.staff };
          moveState.conflicted = false;
          try { block.style.pointerEvents = 'none'; } catch {}
          ev.preventDefault();
          ev.stopPropagation();
          return;
        }
      });

      if (ctxDeleteBtn) {
        ctxDeleteBtn.addEventListener('click', () => {
          if (!currentCtxCell) return;
          const pid = currentCtxCell.dataset.planId;
          closeContextMenu();
          if (!pid) return;
          // If this is a staged new item, remove from pendingCreates instead of server delete
          if (String(pid).startsWith('new-')) {
            const idx = pendingCreates.findIndex(x => x.tempId === pid);
            if (idx >= 0) pendingCreates.splice(idx, 1);
          } else {
            // Stage pending delete
            if (!pendingDeletes.includes(pid)) pendingDeletes.push(pid);
          }
          // Remove the single block and overlay (local only)
          const block = document.getElementById(`plan-block-${pid}`);
          if (block) block.remove();
          const overlay = document.getElementById(`plan-window-${pid}`);
          if (overlay) overlay.remove();
          // Remove from planMap for safety
          delete planMap[pid];
        });
      }

      const editSaveBtn = document.getElementById('editSaveBtn');
      if (editSaveBtn) {
        editSaveBtn.addEventListener('click', async () => {
          if (!currentCtxCell) return;
          const pid = currentCtxCell.dataset.planId;
          const row = Number(currentCtxCell.dataset.row);
          const start = document.getElementById('editStart').value;
          const end = document.getElementById('editEnd').value;
          const staff = document.getElementById('editStaff').value || '1';
          const active = document.getElementById('editActive').checked;
          const note = document.getElementById('editNote').value || '';
          const scheduleType = document.getElementById('editScheduleType').value || 'FIXED';
          const winStart = document.getElementById('editWinStart').value;
          const winEnd = document.getElementById('editWinEnd').value;
          const duration = document.getElementById('editDuration').value;
          // Compute target slots for conflict check
          const startSlot = timeToSlot(scheduleType === 'FIXED' ? start : (winStart || start));
          const endSlot = timeToSlot(scheduleType === 'FIXED' ? end : (winEnd || end));
          if (startSlot < 0 || !(endSlot > startSlot)) {
            alert('開始/終了時刻が不正です');
            return;
          }
          // Conflict check across lanes for this block, excluding same plan id
          if (hasBlockConflict(row, Number(staff || '1'), startSlot, endSlot, pid)) {
            // silently ignore overlapping edits (do not close modal)
            return;
          }

          // Stage update: if new item, update pendingCreates; otherwise stage in pendingUpdates
          if (String(pid).startsWith('new-')) {
            const idx = pendingCreates.findIndex(x => x.tempId === pid);
            if (idx >= 0) {
              const c = pendingCreates[idx];
              c.scheduleType = scheduleType;
              if (scheduleType === 'FIXED') {
                c.fixedStartTime = start; c.fixedEndTime = end;
                c.windowStartTime = undefined; c.windowEndTime = undefined; c.requiredDurationMinutes = undefined;
              } else {
                c.fixedStartTime = undefined; c.fixedEndTime = undefined;
                c.windowStartTime = winStart; c.windowEndTime = winEnd; c.requiredDurationMinutes = duration ? Number(duration) : undefined;
              }
              c.requiredStaffCount = Number(staff);
              c.lane = row + 1;
              pendingCreates[idx] = c;
            }
          } else {
            pendingUpdates.push({ planId: pid, scheduleType, fixedStartTime: start, fixedEndTime: end, windowStartTime: winStart, windowEndTime: winEnd, requiredDurationMinutes: duration ? Number(duration) : undefined, requiredStaffCount: Number(staff), lane: row + 1, active, note });
          }
          try {
            // Update planMap for this plan id
            const p = planMap[pid] || {};
            p.scheduleType = scheduleType;
            if (scheduleType === 'FIXED') {
              p.fixedStartTime = start; p.fixedEndTime = end;
              p.windowStartTime = undefined; p.windowEndTime = undefined; p.requiredDurationMinutes = undefined;
            } else {
              p.fixedStartTime = undefined; p.fixedEndTime = undefined;
              p.windowStartTime = winStart; p.windowEndTime = winEnd; p.requiredDurationMinutes = duration ? Number(duration) : undefined;
            }
            p.requiredStaffCount = Number(staff);
            p.lane = row + 1;
            planMap[pid] = p;
            // Update visual: block/window representation
            const taskCode = currentCtxCell.dataset.taskCode || '';
            const colorClass = getTaskColorClass(taskCode);
            if (scheduleType === 'FIXED') {
              createOrUpdateBlock(row, pid, startSlot, endSlot, taskCode, Number(staff || '1'), colorClass, start, end);
              setSingleHandle(pid, endSlot);
              const oldWin = document.getElementById(`plan-window-${pid}`);
              if (oldWin) oldWin.remove();
            } else {
              const winStartSlot = timeToSlot(winStart);
              const winEndSlot = timeToSlot(winEnd);
              let durationMin = Number(duration || '0');
              // If duration not specified, carry over from start/end
              if ((!durationMin || isNaN(durationMin)) && winStartSlot >= 0 && winEndSlot > winStartSlot) {
                durationMin = (winEndSlot - winStartSlot) * 15;
              }
              const durationSlots = Math.max(1, Math.ceil(durationMin / 15));
              if (winStartSlot >= 0 && winEndSlot > winStartSlot) {
                createOrUpdateWindow(row, pid, winStartSlot, winEndSlot, Number(staff || '1'), colorClass);
                const blockStart = winStartSlot;
                const blockEnd = Math.min(winStartSlot + durationSlots, winEndSlot);
                createOrUpdateBlock(row, pid, blockStart, blockEnd, taskCode, Number(staff || '1'), colorClass, null, null);
                // add handle for FLEXIBLE so length can be adjusted
                setSingleHandle(pid, blockEnd);
              }
            }
            try { if (editModal) editModal.hide(); } catch {}
          } catch (e) {
            alert(e.message || '更新エラー');
          }
        });
      }

      // Delete from edit modal button
      const editDeleteBtn = document.getElementById('editDeleteBtn');
      if (editDeleteBtn) {
        editDeleteBtn.addEventListener('click', () => {
          if (!currentCtxCell) return;
          const pid = currentCtxCell.dataset.planId;
          if (!pid) return;
          // If this is a staged new item, remove from pendingCreates instead of server delete
          if (String(pid).startsWith('new-')) {
            const idx = pendingCreates.findIndex(x => x.tempId === pid);
            if (idx >= 0) pendingCreates.splice(idx, 1);
          } else {
            // Stage pending delete
            if (!pendingDeletes.includes(pid)) pendingDeletes.push(pid);
          }
          // Remove the single block and overlay (local only)
          const block = document.getElementById(`plan-block-${pid}`);
          if (block) block.remove();
          const overlay = document.getElementById(`plan-window-${pid}`);
          if (overlay) overlay.remove();
          // Remove from planMap for safety
          delete planMap[pid];
          try { if (editModal) editModal.hide(); } catch {}
        });
      }

      // One-click commit for staged creates/updates/deletes
      const gridSaveBtn = document.getElementById('gridSaveBtn');
      if (gridSaveBtn) {
        gridSaveBtn.addEventListener('click', async () => {
          gridSaveBtn.disabled = true;
          gridSaveBtn.textContent = '保存中...';
          try {
            const { header, token } = getCsrf();
            // Delete pending plans first
            while (pendingDeletes.length) {
              const id = pendingDeletes.shift();
              const form = new URLSearchParams();
              form.set('store', storeCode);
              form.set('mode', mode);
              if (mode === 'weekly') form.set('day', String(selectedDow || 1)); else if (selectedDate) form.set('sd', formatDate(selectedDate));
              if (selectedDept) form.set('dept', selectedDept);
              const resDel = await fetch(`/tasks/plan/${id}/delete`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...(header && token ? { [header]: token } : {}) }, body: form.toString() });
              if (!resDel.ok) throw new Error('削除に失敗しました');
            }
            // Create pending plans
            while (pendingCreates.length) {
              const c = pendingCreates.shift();
              const form = new URLSearchParams();
              form.set('mode', c.mode);
              form.set('storeCode', c.storeCode);
              if (c.mode === 'weekly') form.set('dayOfWeek', String(c.dayOfWeek)); else form.set('specialDate', c.specialDate);
              form.set('departmentCode', c.departmentCode);
              form.set('taskCode', c.taskCode);
              form.set('scheduleType', 'FIXED');
              form.set('fixedStartTime', c.fixedStartTime);
              form.set('fixedEndTime', c.fixedEndTime);
              form.set('requiredStaffCount', String(c.requiredStaffCount));
              form.set('lane', String(c.lane));
              const res = await fetch('/tasks/plan', { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest', ...(header && token ? { [header]: token } : {}) }, body: form.toString() });
              if (!res.ok) throw new Error('作成に失敗しました');
              const body = await res.json().catch(() => ({}));
              const newId = body?.id;
              if (newId) {
                document.querySelectorAll(`.cell.filled[data-plan-id="${c.tempId}"]`).forEach(el => { el.dataset.planId = String(newId); });
                planMap[String(newId)] = { planId: newId, taskCode: c.taskCode, scheduleType: 'FIXED', fixedStartTime: c.fixedStartTime, fixedEndTime: c.fixedEndTime, lane: c.lane, requiredStaffCount: c.requiredStaffCount };
              }
            }
            // Update pending plans
            while (pendingUpdates.length) {
              const u = pendingUpdates.shift();
              const form = new URLSearchParams();
              form.set('scheduleType', u.scheduleType);
              if (u.scheduleType === 'FIXED') { form.set('fixedStartTime', u.fixedStartTime || ''); form.set('fixedEndTime', u.fixedEndTime || ''); }
              else {
                if (u.windowStartTime) form.set('windowStartTime', u.windowStartTime);
                if (u.windowEndTime) form.set('windowEndTime', u.windowEndTime);
                if (typeof u.requiredDurationMinutes !== 'undefined') form.set('requiredDurationMinutes', String(u.requiredDurationMinutes));
              }
              form.set('requiredStaffCount', String(u.requiredStaffCount));
              form.set('lane', String(u.lane));
              form.set('active', String(u.active));
              if (u.note) form.set('note', u.note);
              form.set('store', storeCode);
              form.set('mode', mode);
              if (mode === 'weekly') form.set('day', String(selectedDow || 1)); else if (selectedDate) form.set('sd', formatDate(selectedDate));
              if (selectedDept) form.set('dept', selectedDept);
              const res = await fetch(`/tasks/plan/${u.planId}/update`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...(header && token ? { [header]: token } : {}) }, body: form.toString() });
              if (!res.ok) throw new Error('更新に失敗しました');
            }
            // All operations finished successfully: reload the page to reflect server state
            window.location.reload();
            return;
          } catch (e) {
            alert(e.message || '保存中にエラーが発生しました');
          } finally {
            gridSaveBtn.disabled = false;
            gridSaveBtn.textContent = '保存';
          }
        });
      }

      function timeLabelFromSlot(slot) {
        const startMin = slot * 15;
        const h = Math.floor(startMin / 60);
        const m = startMin % 60;
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
      }
      function timesFromRange(startSlot, endSlotExclusive) {
        const startMin = startSlot * 15;
        const endMinRaw = endSlotExclusive * 15; // could be 1440 when reaching 24:00
        const endMin = Math.min(endMinRaw, 1439); // clamp to 23:59 to avoid 24:00 parse issues
        const sh = Math.floor(startMin / 60), sm = startMin % 60;
        const eh = Math.floor(endMin / 60), em = endMin % 60;
        return { start: `${String(sh).padStart(2,'0')}:${String(sm).padStart(2,'0')}`, end: `${String(eh).padStart(2,'0')}:${String(em).padStart(2,'0')}` };
      }
      function formatDate(d) {
        try {
          // d may be like '2025-10-10' or Date object/ISO string
          const date = (d instanceof Date) ? d : new Date(d);
          const y = date.getFullYear();
          const m = String(date.getMonth()+1).padStart(2,'0');
          const dd = String(date.getDate()).padStart(2,'0');
          return `${y}-${m}-${dd}`;
        } catch { return ''; }
      }
      function getTaskName(taskCode) {
        if (!masters || !taskCode) return taskCode || '';
        const task = masters.find(m => m.taskCode === taskCode);
        return task ? (task.name || task.taskCode) : taskCode;
      }

      function getTaskColorClass(taskCode) {
        if (!taskCode) return 'task-cell-default';
        
        // Map task codes to color classes
        if (taskCode.includes('REG') || taskCode.includes('レジ')) {
          return 'task-cell-reg';
        } else if (taskCode.includes('STOCK') || taskCode.includes('品出し')) {
          return 'task-cell-stock';
        } else if (taskCode.includes('CLEAN') || taskCode.includes('清掃')) {
          return 'task-cell-clean';
        }
        
        return 'task-cell-default';
      }

      function getCsrf() {
        const header = document.querySelector('meta[name="_csrf_header"]')?.content;
        const token = document.querySelector('meta[name="_csrf"]')?.content;
        return { header, token };
      }

      // Snap helpers for 15-minute increments
      function snapTimeTo15(hhmm) {
        if (!hhmm) return hhmm;
        try {
          const parts = hhmm.split(':');
          if (parts.length < 2) return hhmm;
          let h = Number(parts[0]);
          let m = Number(parts[1]);
          if (isNaN(h) || isNaN(m)) return hhmm;
          let total = h * 60 + m;
          // Round to nearest 15
          total = Math.round(total / 15) * 15;
          // Clamp to 0..(24h - 15)
          if (total < 0) total = 0;
          const max = (24 * 60) - 15;
          if (total > max) total = max;
          const nh = Math.floor(total / 60);
          const nm = total % 60;
          return `${String(nh).padStart(2,'0')}:${String(nm).padStart(2,'0')}`;
        } catch { return hhmm; }
      }
      function snapDurationTo15(minStr) {
        const n = Number(minStr);
        if (isNaN(n)) return minStr;
        if (n <= 0) return '0';
        return String(Math.round(n / 15) * 15);
      }

      // Attach snapping to all time/duration inputs
      function attachSnapListeners() {
        document.querySelectorAll('input[type="time"]').forEach(inp => {
          inp.addEventListener('change', () => { inp.value = snapTimeTo15(inp.value); });
          inp.addEventListener('blur', () => { inp.value = snapTimeTo15(inp.value); });
        });
        document.querySelectorAll('input[type="number"][step="15"]').forEach(inp => {
          inp.addEventListener('change', () => { inp.value = snapDurationTo15(inp.value); });
          inp.addEventListener('blur', () => { inp.value = snapDurationTo15(inp.value); });
        });
      }
      attachSnapListeners();

      // Inline warning helper for conflicts
      function showInlineWarning(msg) {
        const el = document.getElementById('gridMessage');
        if (!el) return;
        el.textContent = msg || '';
        el.classList.remove('d-none');
        el.classList.remove('alert-success', 'alert-info');
        el.classList.add('alert-danger');
        if (el._hideTimer) { clearTimeout(el._hideTimer); }
        el._hideTimer = setTimeout(() => {
          el.classList.add('d-none');
        }, 3000);
      }

      // Editable table functionality
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('save-btn') || e.target.closest('.save-btn')) {
          const row = e.target.closest('tr');
          savePlanRow(row);
        } else if (e.target.classList.contains('reset-btn') || e.target.closest('.reset-btn')) {
          const row = e.target.closest('tr');
          resetPlanRow(row);
        } else if (e.target.classList.contains('delete-btn') || e.target.closest('.delete-btn')) {
          const row = e.target.closest('tr');
          deletePlanRow(row);
        }
      });

      async function savePlanRow(row) {
        const planId = row.dataset.planId;
        if (!planId) return;
        
        const formData = new URLSearchParams();
        const inputs = row.querySelectorAll('input, select');
        
        inputs.forEach(input => {
          if (input.name && input.value) {
            formData.append(input.name, input.value);
          }
        });
        
        // Add required parameters
        formData.append('store', storeCode);
        formData.append('mode', mode);
        if (mode === 'weekly') {
          formData.append('day', String(selectedDow || 1));
        } else if (selectedDate) {
          formData.append('sd', formatDate(selectedDate));
        }
        if (selectedDept) {
          formData.append('dept', selectedDept);
        }

        try {
          const { header, token } = getCsrf();
          const response = await fetch(`/tasks/plan/${planId}/update`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              ...(header && token ? { [header]: token } : {})
            },
            body: formData.toString()
          });
          
          if (!response.ok) {
            throw new Error('更新に失敗しました');
          }
          
          // Update data-original attributes
          inputs.forEach(input => {
            input.setAttribute('data-original', input.value);
          });
          
          // Visual feedback
          row.style.backgroundColor = '#d4edda';
          setTimeout(() => {
            row.style.backgroundColor = '';
          }, 2000);
          
        } catch (error) {
          alert(error.message || '保存エラーが発生しました');
        }
      }

      function resetPlanRow(row) {
        const inputs = row.querySelectorAll('input, select');
        inputs.forEach(input => {
          const original = input.getAttribute('data-original');
          if (original !== null) {
            input.value = original;
          }
        });
      }

      async function deletePlanRow(row) {
        const planId = row.dataset.planId;
        if (!planId) return;
        // Stage pending delete (handle staged new)
        if (String(planId).startsWith('new-')) {
          const idx = pendingCreates.findIndex(x => x.tempId === planId);
          if (idx >= 0) pendingCreates.splice(idx, 1);
        } else {
          if (!pendingDeletes.includes(planId)) pendingDeletes.push(planId);
        }
        // Remove row immediately
        row.remove();
        // Clear from grid if visible (single-block and overlay)
        const block = document.getElementById(`plan-block-${planId}`);
        if (block) block.remove();
        const overlay = document.getElementById(`plan-window-${planId}`);
        if (overlay) overlay.remove();
        // Fallback: clear any legacy cell paints
        document.querySelectorAll(`.cell.filled[data-plan-id="${planId}"]`).forEach(el => {
          el.className = 'cell';
          el.removeAttribute('data-plan-id');
          el.removeAttribute('data-task-code');
          el.removeAttribute('data-staff');
          el.innerHTML = '';
        });
        delete planMap[planId];
      }
    });
  </script>
</main>
</body>
</html>
